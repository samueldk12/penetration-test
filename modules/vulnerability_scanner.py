"""
Comprehensive Vulnerability Scanner
Tests for multiple vulnerability types with extensive payloads
"""

import requests
import re
import time
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Any
from modules.payloads import PayloadDatabase
from modules.logger import Severity
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for web applications"""

    def __init__(self, target, logger, threads=10, timeout=10, proxy=None, verify_ssl=True):
        self.target = target
        self.logger = logger
        self.threads = threads
        self.timeout = timeout
        self.proxy = proxy
        self.verify_ssl = verify_ssl
        self.session = self._init_session()
        self.payloads = PayloadDatabase()

    def _init_session(self):
        """Initialize HTTP session"""
        session = requests.Session()
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        if self.proxy:
            session.proxies = {'http': self.proxy, 'https': self.proxy}
        return session

    def run_all_scans(self) -> Dict[str, List[Dict]]:
        """Execute all vulnerability scans"""
        results = {}

        scan_modules = [
            ('XSS', self.scan_xss),
            ('SQL Injection', self.scan_sqli),
            ('Command Injection', self.scan_command_injection),
            ('SSRF', self.scan_ssrf),
            ('XXE', self.scan_xxe),
            ('Path Traversal', self.scan_path_traversal),
            ('LDAP Injection', self.scan_ldap_injection),
            ('NoSQL Injection', self.scan_nosql_injection),
            ('Open Redirect', self.scan_open_redirect),
            ('CRLF Injection', self.scan_crlf_injection),
            ('SSTI', self.scan_ssti),
            ('IDOR', self.scan_idor),
            ('Insecure Deserialization', self.scan_insecure_deserialization),
            ('CORS Misconfiguration', self.scan_cors),
            ('Clickjacking', self.scan_clickjacking),
        ]

        for scan_name, scan_func in scan_modules:
            try:
                self.logger.log_info(f"Running {scan_name} scan...")
                vulns = scan_func()
                results[scan_name] = vulns
                if vulns:
                    self.logger.log_success(f"{scan_name}: {len(vulns)} vulnerabilities found")
            except Exception as e:
                self.logger.log_error(f"Error in {scan_name} scan: {str(e)}")
                results[scan_name] = []

        return results

    def scan_xss(self) -> List[Dict]:
        """Scan for XSS vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('xss')

        # Get forms and test parameters
        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']
            method = param_info.get('method', 'GET')

            for payload in payloads[:30]:  # Test first 30 payloads per parameter
                try:
                    if method.upper() == 'GET':
                        test_url = self._inject_param(url, param_name, payload)
                        response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)
                    else:
                        data = {param_name: payload}
                        response = self.session.post(url, data=data, timeout=self.timeout, verify=self.verify_ssl)

                    # Check if payload is reflected
                    if payload in response.text or payload.lower() in response.text.lower():
                        # Check if it's in executable context
                        if self._is_xss_exploitable(response.text, payload):
                            vuln = {
                                'name': 'Cross-Site Scripting (XSS)',
                                'severity': Severity.HIGH.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to Cross-Site Scripting (XSS) in the {param_name} parameter. User input is not properly sanitized and is reflected in the response without encoding.',
                                'impact': 'An attacker can execute arbitrary JavaScript code in the victim\'s browser, potentially stealing session cookies, performing actions on behalf of the user, or defacing the website.',
                                'remediation': 'Implement proper input validation and output encoding. Use Content Security Policy (CSP) headers. Escape all user input before rendering in HTML context.',
                                'request': f"{method} {test_url}" if method == 'GET' else f"POST {url}\nData: {param_name}={payload}",
                                'response': response.text[:1000],
                                'cvss_score': '7.1',
                                'cwe_id': 'CWE-79',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break  # Found XSS in this parameter, move to next

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_sqli(self) -> List[Dict]:
        """Scan for SQL Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('sqli')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']
            method = param_info.get('method', 'GET')

            for payload in payloads[:25]:  # Test first 25 payloads
                try:
                    if method.upper() == 'GET':
                        test_url = self._inject_param(url, param_name, payload)
                        start_time = time.time()
                        response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)
                        elapsed_time = time.time() - start_time
                    else:
                        data = {param_name: payload}
                        start_time = time.time()
                        response = self.session.post(url, data=data, timeout=self.timeout, verify=self.verify_ssl)
                        elapsed_time = time.time() - start_time

                    # Check for SQL errors
                    sql_errors = [
                        'sql syntax', 'mysql_fetch', 'mysql error', 'mysqli',
                        'odbc', 'postgresql', 'ora-', 'sqlite', 'db2',
                        'warning: mysql', 'unclosed quotation mark',
                        'syntax error', 'unterminated string', 'microsoft ole db',
                        'Microsoft Access Driver', 'JET Database Engine',
                    ]

                    if any(error.lower() in response.text.lower() for error in sql_errors):
                        vuln = {
                            'name': 'SQL Injection',
                            'severity': Severity.CRITICAL.value,
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'description': f'The application is vulnerable to SQL Injection in the {param_name} parameter. SQL errors were detected in the response, indicating that user input is being processed in SQL queries without proper sanitization.',
                            'impact': 'An attacker can manipulate SQL queries to access, modify, or delete database contents. This can lead to complete database compromise, unauthorized data access, authentication bypass, and potential server takeover.',
                            'remediation': 'Use parameterized queries (prepared statements) for all database interactions. Implement proper input validation. Use stored procedures with parameterized inputs. Apply principle of least privilege for database accounts.',
                            'request': f"{method} {test_url}" if method == 'GET' else f"POST {url}\nData: {param_name}={payload}",
                            'response': response.text[:1000],
                            'cvss_score': '9.8',
                            'cwe_id': 'CWE-89',
                        }
                        vulnerabilities.append(vuln)
                        self.logger.log_vulnerability(vuln)
                        break

                    # Check for time-based blind SQLi
                    if 'SLEEP' in payload.upper() or 'WAITFOR' in payload.upper():
                        if elapsed_time >= 5:  # If response took 5+ seconds
                            vuln = {
                                'name': 'Time-Based Blind SQL Injection',
                                'severity': Severity.CRITICAL.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to Time-Based Blind SQL Injection in the {param_name} parameter. The application response time increased significantly when time-based SQL injection payload was injected.',
                                'impact': 'An attacker can extract data from the database by observing time delays, even without error messages. This can lead to complete database compromise through time-based enumeration.',
                                'remediation': 'Use parameterized queries (prepared statements) for all database interactions. Implement proper input validation and sanitization.',
                                'request': f"{method} {test_url}" if method == 'GET' else f"POST {url}\nData: {param_name}={payload}",
                                'response': f"Response time: {elapsed_time:.2f}s",
                                'cvss_score': '9.8',
                                'cwe_id': 'CWE-89',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_command_injection(self) -> List[Dict]:
        """Scan for Command Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('cmd_injection')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            for payload in payloads[:20]:
                try:
                    test_url = self._inject_param(url, param_name, payload)
                    start_time = time.time()
                    response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)
                    elapsed_time = time.time() - start_time

                    # Command injection indicators
                    cmd_indicators = [
                        'root:', 'daemon:', 'bin:', 'sys:',  # /etc/passwd
                        'uid=', 'gid=', 'groups=',  # id command
                        'inet addr:', 'broadcast', 'netmask',  # ifconfig
                        'Volume Serial Number',  # Windows dir
                        'Directory of',  # Windows dir
                    ]

                    if any(indicator in response.text for indicator in cmd_indicators):
                        vuln = {
                            'name': 'OS Command Injection',
                            'severity': Severity.CRITICAL.value,
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'description': f'The application is vulnerable to OS Command Injection in the {param_name} parameter. The application executes system commands with user-supplied input without proper validation.',
                            'impact': 'An attacker can execute arbitrary operating system commands on the server, potentially leading to complete system compromise, data theft, malware installation, or use as a pivot point for further attacks.',
                            'remediation': 'Never pass user input directly to system commands. Use safe APIs instead of shell commands. If system commands are necessary, use strict input validation with whitelist approach. Implement proper sandboxing.',
                            'request': f"GET {test_url}",
                            'response': response.text[:1000],
                            'cvss_score': '9.8',
                            'cwe_id': 'CWE-78',
                        }
                        vulnerabilities.append(vuln)
                        self.logger.log_vulnerability(vuln)
                        break

                    # Time-based detection
                    if 'sleep' in payload.lower() or 'timeout' in payload.lower():
                        if elapsed_time >= 5:
                            vuln = {
                                'name': 'Blind OS Command Injection',
                                'severity': Severity.CRITICAL.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to Blind OS Command Injection in the {param_name} parameter. Time-based command injection was successful.',
                                'impact': 'An attacker can execute arbitrary operating system commands, even without seeing the output directly.',
                                'remediation': 'Never pass user input directly to system commands. Use safe APIs instead of shell commands.',
                                'request': f"GET {test_url}",
                                'response': f"Response time: {elapsed_time:.2f}s",
                                'cvss_score': '9.8',
                                'cwe_id': 'CWE-78',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_ssrf(self) -> List[Dict]:
        """Scan for Server-Side Request Forgery vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('ssrf')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            # Focus on URL-like parameters
            if any(keyword in param_name.lower() for keyword in ['url', 'uri', 'path', 'redirect', 'link', 'src', 'source']):
                for payload in payloads[:15]:
                    try:
                        test_url = self._inject_param(url, param_name, payload)
                        response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl, allow_redirects=False)

                        # Check for SSRF indicators
                        ssrf_indicators = [
                            'hostname', 'ami-id', 'instance-id',  # AWS metadata
                            'private', '127.0.0.1', 'localhost',
                            'file://', 'dict://', 'gopher://',
                        ]

                        if any(indicator in response.text.lower() for indicator in ssrf_indicators):
                            vuln = {
                                'name': 'Server-Side Request Forgery (SSRF)',
                                'severity': Severity.HIGH.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to Server-Side Request Forgery (SSRF) in the {param_name} parameter. The server makes requests to attacker-controlled URLs.',
                                'impact': 'An attacker can make the server perform requests to internal resources, cloud metadata endpoints, or other systems. This can lead to accessing internal services, reading sensitive data, or port scanning internal networks.',
                                'remediation': 'Implement strict URL validation with whitelist approach. Block access to internal IP ranges and cloud metadata endpoints. Use network segmentation.',
                                'request': f"GET {test_url}",
                                'response': response.text[:1000],
                                'cvss_score': '8.6',
                                'cwe_id': 'CWE-918',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                    except Exception as e:
                        continue

        return vulnerabilities

    def scan_xxe(self) -> List[Dict]:
        """Scan for XXE (XML External Entity) vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('xxe')

        try:
            for payload in payloads[:5]:
                response = self.session.post(
                    self.target,
                    data=payload,
                    headers={'Content-Type': 'application/xml'},
                    timeout=self.timeout,
                    verify=self.verify_ssl
                )

                # XXE indicators
                xxe_indicators = [
                    'root:', 'daemon:',  # /etc/passwd
                    'localhost', '127.0.0.1',
                    '<?xml', 'DOCTYPE',
                ]

                if any(indicator in response.text for indicator in xxe_indicators):
                    vuln = {
                        'name': 'XML External Entity (XXE) Injection',
                        'severity': Severity.HIGH.value,
                        'url': self.target,
                        'parameter': 'XML Body',
                        'payload': payload,
                        'description': 'The application is vulnerable to XML External Entity (XXE) injection. The XML parser processes external entities, allowing an attacker to read files or perform SSRF attacks.',
                        'impact': 'An attacker can read sensitive files from the server, perform SSRF attacks, cause denial of service, or execute remote code in certain configurations.',
                        'remediation': 'Disable XML external entity processing in all XML parsers. Use simple data formats like JSON when possible. Implement proper input validation.',
                        'request': f"POST {self.target}\nContent-Type: application/xml\n\n{payload}",
                        'response': response.text[:1000],
                        'cvss_score': '8.2',
                        'cwe_id': 'CWE-611',
                    }
                    vulnerabilities.append(vuln)
                    self.logger.log_vulnerability(vuln)
                    break

        except Exception as e:
            pass

        return vulnerabilities

    def scan_path_traversal(self) -> List[Dict]:
        """Scan for Path Traversal vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('path_traversal')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            # Focus on file-related parameters
            if any(keyword in param_name.lower() for keyword in ['file', 'path', 'page', 'document', 'folder', 'dir']):
                for payload in payloads[:20]:
                    try:
                        test_url = self._inject_param(url, param_name, payload)
                        response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)

                        # Path traversal indicators
                        path_indicators = [
                            'root:', 'daemon:', 'bin:',  # /etc/passwd
                            '[extensions]', '[fonts]',  # Windows win.ini
                            'for 16-bit app support',
                        ]

                        if any(indicator.lower() in response.text.lower() for indicator in path_indicators):
                            vuln = {
                                'name': 'Path Traversal / Directory Traversal',
                                'severity': Severity.HIGH.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to Path Traversal in the {param_name} parameter. An attacker can access files outside the intended directory.',
                                'impact': 'An attacker can read sensitive files from the server, potentially exposing configuration files, source code, credentials, or other sensitive data.',
                                'remediation': 'Use whitelist approach for file access. Avoid using user input for file paths. Use path canonicalization and validation. Implement proper access controls.',
                                'request': f"GET {test_url}",
                                'response': response.text[:1000],
                                'cvss_score': '7.5',
                                'cwe_id': 'CWE-22',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                    except Exception as e:
                        continue

        return vulnerabilities

    def scan_ldap_injection(self) -> List[Dict]:
        """Scan for LDAP Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('ldap_injection')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            for payload in payloads[:10]:
                try:
                    test_url = self._inject_param(url, param_name, payload)
                    response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)

                    # LDAP error indicators
                    ldap_indicators = [
                        'ldap', 'javax.naming', 'LdapException',
                        'invalid DN syntax', 'objectClass',
                    ]

                    if any(indicator.lower() in response.text.lower() for indicator in ldap_indicators):
                        vuln = {
                            'name': 'LDAP Injection',
                            'severity': Severity.HIGH.value,
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'description': f'The application is vulnerable to LDAP Injection in the {param_name} parameter.',
                            'impact': 'An attacker can manipulate LDAP queries to bypass authentication, access unauthorized data, or modify LDAP directory contents.',
                            'remediation': 'Use parameterized LDAP queries. Implement proper input validation and escaping for LDAP special characters.',
                            'request': f"GET {test_url}",
                            'response': response.text[:1000],
                            'cvss_score': '8.1',
                            'cwe_id': 'CWE-90',
                        }
                        vulnerabilities.append(vuln)
                        self.logger.log_vulnerability(vuln)
                        break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_nosql_injection(self) -> List[Dict]:
        """Scan for NoSQL Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('nosql_injection')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            for payload in payloads[:10]:
                try:
                    # Try JSON injection
                    headers = {'Content-Type': 'application/json'}
                    response = self.session.post(
                        url,
                        json={param_name: payload},
                        headers=headers,
                        timeout=self.timeout,
                        verify=self.verify_ssl
                    )

                    # NoSQL indicators (successful authentication bypass or data leak)
                    if response.status_code == 200 and len(response.text) > 0:
                        if 'admin' in response.text.lower() or 'user' in response.text.lower():
                            vuln = {
                                'name': 'NoSQL Injection',
                                'severity': Severity.HIGH.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': str(payload),
                                'description': f'The application is vulnerable to NoSQL Injection in the {param_name} parameter.',
                                'impact': 'An attacker can manipulate NoSQL queries to bypass authentication, access unauthorized data, or extract the entire database.',
                                'remediation': 'Use parameterized queries or ODM/ORM layers. Implement proper input validation. Use strict type checking.',
                                'request': f"POST {url}\nContent-Type: application/json\n{param_name}: {payload}",
                                'response': response.text[:1000],
                                'cvss_score': '8.1',
                                'cwe_id': 'CWE-943',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_open_redirect(self) -> List[Dict]:
        """Scan for Open Redirect vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('open_redirect')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            # Focus on redirect-related parameters
            if any(keyword in param_name.lower() for keyword in ['redirect', 'url', 'next', 'return', 'redir', 'goto', 'target']):
                for payload in payloads[:10]:
                    try:
                        test_url = self._inject_param(url, param_name, payload)
                        response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl, allow_redirects=False)

                        # Check for redirect
                        if response.status_code in [301, 302, 303, 307, 308]:
                            location = response.headers.get('Location', '')
                            if 'evil.com' in location or 'google.com' in location:
                                vuln = {
                                    'name': 'Open Redirect',
                                    'severity': Severity.MEDIUM.value,
                                    'url': url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'description': f'The application is vulnerable to Open Redirect in the {param_name} parameter. The application redirects to user-controlled URLs.',
                                    'impact': 'An attacker can redirect users to malicious websites, potentially for phishing attacks or malware distribution.',
                                    'remediation': 'Implement whitelist of allowed redirect URLs. Validate redirect destinations. Use relative URLs when possible.',
                                    'request': f"GET {test_url}",
                                    'response': f"Location: {location}",
                                    'cvss_score': '6.1',
                                    'cwe_id': 'CWE-601',
                                }
                                vulnerabilities.append(vuln)
                                self.logger.log_vulnerability(vuln)
                                break

                    except Exception as e:
                        continue

        return vulnerabilities

    def scan_crlf_injection(self) -> List[Dict]:
        """Scan for CRLF Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('crlf_injection')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            for payload in payloads[:10]:
                try:
                    test_url = self._inject_param(url, param_name, payload)
                    response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl, allow_redirects=False)

                    # Check for injected headers
                    if 'Set-Cookie' in response.headers or 'Location' in response.headers:
                        if 'malicious' in str(response.headers).lower() or 'admin=true' in str(response.headers).lower():
                            vuln = {
                                'name': 'CRLF Injection',
                                'severity': Severity.MEDIUM.value,
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f'The application is vulnerable to CRLF Injection in the {param_name} parameter. An attacker can inject HTTP headers.',
                                'impact': 'An attacker can inject arbitrary HTTP headers, potentially leading to XSS, session fixation, cache poisoning, or HTTP response splitting attacks.',
                                'remediation': 'Remove or encode CRLF characters from user input. Validate all input used in HTTP headers.',
                                'request': f"GET {test_url}",
                                'response': f"Headers: {dict(response.headers)}",
                                'cvss_score': '6.5',
                                'cwe_id': 'CWE-93',
                            }
                            vulnerabilities.append(vuln)
                            self.logger.log_vulnerability(vuln)
                            break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_ssti(self) -> List[Dict]:
        """Scan for Server-Side Template Injection vulnerabilities"""
        vulnerabilities = []
        payloads = self.payloads.get_all_payloads('ssti')

        test_params = self._discover_parameters()

        for param_info in test_params:
            url = param_info['url']
            param_name = param_info['name']

            for payload in payloads[:15]:
                try:
                    test_url = self._inject_param(url, param_name, payload)
                    response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)

                    # Check for template injection
                    if '49' in response.text or '7777777' in response.text:  # 7*7 = 49, 7*7*7*7*7*7*7 = 7777777
                        vuln = {
                            'name': 'Server-Side Template Injection (SSTI)',
                            'severity': Severity.CRITICAL.value,
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'description': f'The application is vulnerable to Server-Side Template Injection (SSTI) in the {param_name} parameter.',
                            'impact': 'An attacker can execute arbitrary code on the server, potentially leading to complete system compromise, data theft, or server takeover.',
                            'remediation': 'Never pass user input directly to template engines. Use sandboxed template environments. Implement strict input validation.',
                            'request': f"GET {test_url}",
                            'response': response.text[:1000],
                            'cvss_score': '9.8',
                            'cwe_id': 'CWE-94',
                        }
                        vulnerabilities.append(vuln)
                        self.logger.log_vulnerability(vuln)
                        break

                except Exception as e:
                    continue

        return vulnerabilities

    def scan_idor(self) -> List[Dict]:
        """Scan for IDOR (Insecure Direct Object Reference) vulnerabilities"""
        vulnerabilities = []

        try:
            # Look for numeric IDs in URL
            if re.search(r'/\d+', self.target):
                # Try accessing different IDs
                for test_id in [1, 2, 3, 100, 999, 1000]:
                    test_url = re.sub(r'/\d+', f'/{test_id}', self.target)
                    response = self.session.get(test_url, timeout=self.timeout, verify=self.verify_ssl)

                    if response.status_code == 200:
                        vuln = {
                            'name': 'Insecure Direct Object Reference (IDOR)',
                            'severity': Severity.HIGH.value,
                            'url': test_url,
                            'parameter': 'ID in URL',
                            'payload': str(test_id),
                            'description': 'The application is vulnerable to IDOR. Sequential IDs can be accessed without proper authorization checks.',
                            'impact': 'An attacker can access or modify other users\' data by manipulating object references (IDs), leading to unauthorized information disclosure or data manipulation.',
                            'remediation': 'Implement proper authorization checks for every object access. Use non-sequential, unpredictable identifiers. Validate user permissions on server-side.',
                            'request': f"GET {test_url}",
                            'response': response.text[:1000],
                            'cvss_score': '7.5',
                            'cwe_id': 'CWE-639',
                        }
                        vulnerabilities.append(vuln)
                        self.logger.log_vulnerability(vuln)
                        break

        except Exception as e:
            pass

        return vulnerabilities

    def scan_insecure_deserialization(self) -> List[Dict]:
        """Scan for Insecure Deserialization vulnerabilities"""
        vulnerabilities = []

        # Python pickle payload
        serialized_payloads = [
            'rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAQm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5jb21wYXJhdG9ycy5UcmFuc2Zvcm1pbmdDb21wYXJhdG9y',
        ]

        try:
            for payload in serialized_payloads:
                response = self.session.post(
                    self.target,
                    data=payload,
                    timeout=self.timeout,
                    verify=self.verify_ssl
                )

                if response.status_code in [200, 500]:
                    vuln = {
                        'name': 'Insecure Deserialization',
                        'severity': Severity.CRITICAL.value,
                        'url': self.target,
                        'parameter': 'Request Body',
                        'payload': payload[:100],
                        'description': 'The application may be vulnerable to Insecure Deserialization. It processes serialized objects without proper validation.',
                        'impact': 'An attacker can execute arbitrary code, bypass authentication, or perform other malicious actions by manipulating serialized objects.',
                        'remediation': 'Avoid deserializing untrusted data. Use safe serialization formats like JSON. Implement integrity checks and type validation.',
                        'request': f"POST {self.target}",
                        'response': response.text[:1000],
                        'cvss_score': '9.8',
                        'cwe_id': 'CWE-502',
                    }
                    vulnerabilities.append(vuln)
                    self.logger.log_vulnerability(vuln)

        except Exception as e:
            pass

        return vulnerabilities

    def scan_cors(self) -> List[Dict]:
        """Scan for CORS Misconfiguration"""
        vulnerabilities = []

        malicious_origins = [
            'https://evil.com',
            'https://attacker.com',
            'null',
        ]

        try:
            for origin in malicious_origins:
                headers = {'Origin': origin}
                response = self.session.get(self.target, headers=headers, timeout=self.timeout, verify=self.verify_ssl)

                acao = response.headers.get('Access-Control-Allow-Origin', '')
                acac = response.headers.get('Access-Control-Allow-Credentials', '')

                if acao == origin or acao == '*':
                    severity = Severity.HIGH.value if acac == 'true' else Severity.MEDIUM.value
                    vuln = {
                        'name': 'CORS Misconfiguration',
                        'severity': severity,
                        'url': self.target,
                        'parameter': 'CORS Headers',
                        'payload': origin,
                        'description': f'The application has a CORS misconfiguration. It reflects the Origin header ({origin}) in Access-Control-Allow-Origin.',
                        'impact': 'An attacker can make cross-origin requests from malicious domains, potentially accessing sensitive user data or performing actions on behalf of the user.',
                        'remediation': 'Implement strict CORS policy with whitelist of trusted origins. Avoid reflecting Origin header. Be careful with Access-Control-Allow-Credentials.',
                        'request': f"GET {self.target}\nOrigin: {origin}",
                        'response': f"Access-Control-Allow-Origin: {acao}\nAccess-Control-Allow-Credentials: {acac}",
                        'cvss_score': '7.4' if acac == 'true' else '5.3',
                        'cwe_id': 'CWE-346',
                    }
                    vulnerabilities.append(vuln)
                    self.logger.log_vulnerability(vuln)
                    break

        except Exception as e:
            pass

        return vulnerabilities

    def scan_clickjacking(self) -> List[Dict]:
        """Scan for Clickjacking vulnerabilities"""
        vulnerabilities = []

        try:
            response = self.session.get(self.target, timeout=self.timeout, verify=self.verify_ssl)

            x_frame_options = response.headers.get('X-Frame-Options', None)
            csp = response.headers.get('Content-Security-Policy', '')

            if not x_frame_options and 'frame-ancestors' not in csp:
                vuln = {
                    'name': 'Clickjacking',
                    'severity': Severity.MEDIUM.value,
                    'url': self.target,
                    'parameter': 'Security Headers',
                    'payload': 'N/A',
                    'description': 'The application is vulnerable to Clickjacking. It lacks X-Frame-Options header and CSP frame-ancestors directive.',
                    'impact': 'An attacker can embed the application in a malicious iframe and trick users into clicking on hidden elements, potentially performing unintended actions.',
                    'remediation': 'Implement X-Frame-Options: DENY or SAMEORIGIN header. Use Content-Security-Policy frame-ancestors directive.',
                    'request': f"GET {self.target}",
                    'response': 'Missing: X-Frame-Options and CSP frame-ancestors',
                    'cvss_score': '4.3',
                    'cwe_id': 'CWE-1021',
                }
                vulnerabilities.append(vuln)
                self.logger.log_vulnerability(vuln)

        except Exception as e:
            pass

        return vulnerabilities

    def _discover_parameters(self) -> List[Dict]:
        """Discover parameters from target URL and forms"""
        parameters = []

        # Parse URL parameters
        parsed = urlparse(self.target)
        query_params = parse_qs(parsed.query)

        for param_name in query_params.keys():
            parameters.append({
                'url': self.target,
                'name': param_name,
                'method': 'GET'
            })

        # Try to discover forms
        try:
            response = self.session.get(self.target, timeout=self.timeout, verify=self.verify_ssl)
            form_pattern = r'<form[^>]*>(.*?)</form>'
            forms = re.findall(form_pattern, response.text, re.IGNORECASE | re.DOTALL)

            for form in forms:
                action_match = re.search(r'action=["\'](.*?)["\']', form, re.IGNORECASE)
                method_match = re.search(r'method=["\'](.*?)["\']', form, re.IGNORECASE)

                action = action_match.group(1) if action_match else self.target
                method = method_match.group(1).upper() if method_match else 'GET'

                input_pattern = r'<input[^>]+name=["\'](.*?)["\']'
                inputs = re.findall(input_pattern, form, re.IGNORECASE)

                for input_name in inputs:
                    parameters.append({
                        'url': urljoin(self.target, action),
                        'name': input_name,
                        'method': method
                    })

        except Exception as e:
            pass

        # Add common parameter names if none found
        if not parameters:
            common_params = ['id', 'page', 'file', 'url', 'search', 'q', 'query', 'redirect', 'next']
            for param in common_params:
                parameters.append({
                    'url': self.target,
                    'name': param,
                    'method': 'GET'
                })

        return parameters

    def _inject_param(self, url: str, param_name: str, payload: str) -> str:
        """Inject payload into URL parameter"""
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        query_params[param_name] = [payload]

        new_query = urlencode(query_params, doseq=True)
        new_parsed = parsed._replace(query=new_query)

        return urlunparse(new_parsed)

    def _is_xss_exploitable(self, html: str, payload: str) -> bool:
        """Check if reflected payload is in exploitable context"""
        # Check if payload is in script context or unencoded in HTML
        dangerous_contexts = [
            f'<script>{payload}',
            f'>{payload}<',
            f'"{payload}"',
            f"'{payload}'",
            f'={payload}',
        ]

        return any(context in html for context in dangerous_contexts)
