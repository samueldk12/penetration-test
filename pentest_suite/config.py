"""
Módulo de Configuração para Scanners
Gerencia proxies, SSL, autenticação e outras configurações avançadas
"""

from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
import requests
from requests.auth import HTTPBasicAuth, HTTPDigestAuth
import warnings


@dataclass
class ScanConfig:
    """Configuração completa para scanners"""

    # Proxy settings
    proxies: Optional[Dict[str, str]] = None
    proxy_list: Optional[List[Dict[str, str]]] = None
    rotate_proxy: bool = False
    current_proxy_index: int = 0

    # SSL/TLS settings
    verify_ssl: bool = False
    ssl_cert: Optional[str] = None
    ssl_key: Optional[str] = None

    # Authentication
    auth_type: Optional[str] = None  # 'basic', 'digest', 'bearer', 'custom'
    username: Optional[str] = None
    password: Optional[str] = None
    bearer_token: Optional[str] = None
    custom_headers: Dict[str, str] = field(default_factory=dict)

    # Request settings
    timeout: int = 10
    max_retries: int = 3
    retry_delay: int = 2
    user_agent: str = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'

    # Rate limiting
    requests_per_second: Optional[float] = None
    delay_between_requests: float = 0

    # Advanced settings
    follow_redirects: bool = True
    max_redirects: int = 5
    cookies: Optional[Dict[str, str]] = None

    def __post_init__(self):
        """Inicialização após criação do objeto"""
        if not self.verify_ssl:
            # Desabilita warnings de SSL
            warnings.filterwarnings('ignore', message='Unverified HTTPS request')

    def get_session(self) -> requests.Session:
        """
        Cria uma sessão requests configurada
        """
        session = requests.Session()

        # Configura User-Agent
        session.headers.update({
            'User-Agent': self.user_agent
        })

        # Adiciona headers customizados
        if self.custom_headers:
            session.headers.update(self.custom_headers)

        # Configura autenticação
        if self.auth_type == 'basic' and self.username and self.password:
            session.auth = HTTPBasicAuth(self.username, self.password)
        elif self.auth_type == 'digest' and self.username and self.password:
            session.auth = HTTPDigestAuth(self.username, self.password)
        elif self.auth_type == 'bearer' and self.bearer_token:
            session.headers['Authorization'] = f'Bearer {self.bearer_token}'

        # Configura SSL
        session.verify = self.verify_ssl
        if self.ssl_cert:
            session.cert = (self.ssl_cert, self.ssl_key) if self.ssl_key else self.ssl_cert

        # Configura proxy
        if self.rotate_proxy and self.proxy_list:
            session.proxies = self._get_next_proxy()
        elif self.proxies:
            session.proxies = self.proxies

        # Configura cookies
        if self.cookies:
            session.cookies.update(self.cookies)

        # Configura redirects
        session.max_redirects = self.max_redirects

        return session

    def _get_next_proxy(self) -> Dict[str, str]:
        """Rotaciona para o próximo proxy na lista"""
        if not self.proxy_list:
            return {}

        proxy = self.proxy_list[self.current_proxy_index]
        self.current_proxy_index = (self.current_proxy_index + 1) % len(self.proxy_list)
        return proxy

    def to_dict(self) -> Dict:
        """Converte configuração para dicionário"""
        return {
            'proxies': self.proxies,
            'proxy_list': self.proxy_list,
            'verify_ssl': self.verify_ssl,
            'auth_type': self.auth_type,
            'timeout': self.timeout,
            'max_retries': self.max_retries,
            'user_agent': self.user_agent,
            'requests_per_second': self.requests_per_second,
        }

    @classmethod
    def from_dict(cls, config_dict: Dict) -> 'ScanConfig':
        """Cria configuração a partir de dicionário"""
        return cls(**config_dict)

    @classmethod
    def from_file(cls, config_file: str) -> 'ScanConfig':
        """Carrega configuração de arquivo JSON"""
        import json
        with open(config_file, 'r') as f:
            config_dict = json.load(f)
        return cls.from_dict(config_dict)


class ProxyManager:
    """Gerenciador de proxies"""

    def __init__(self, proxy_file: Optional[str] = None):
        self.proxies: List[Dict[str, str]] = []
        if proxy_file:
            self.load_from_file(proxy_file)

    def load_from_file(self, proxy_file: str):
        """
        Carrega proxies de arquivo
        Formato esperado (um por linha):
        http://proxy1:8080
        http://user:pass@proxy2:8080
        socks5://proxy3:1080
        """
        with open(proxy_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    proxy = self._parse_proxy(line)
                    if proxy:
                        self.proxies.append(proxy)

        print(f"[+] Carregados {len(self.proxies)} proxies")

    def _parse_proxy(self, proxy_str: str) -> Optional[Dict[str, str]]:
        """Parse string de proxy para formato requests"""
        try:
            # Formato: http://proxy:port ou http://user:pass@proxy:port
            if proxy_str.startswith('http://') or proxy_str.startswith('https://'):
                return {
                    'http': proxy_str,
                    'https': proxy_str
                }
            elif proxy_str.startswith('socks5://'):
                return {
                    'http': proxy_str,
                    'https': proxy_str
                }
            else:
                # Assume http se não especificado
                return {
                    'http': f'http://{proxy_str}',
                    'https': f'http://{proxy_str}'
                }
        except Exception as e:
            print(f"[-] Erro ao parse proxy '{proxy_str}': {e}")
            return None

    def get_all(self) -> List[Dict[str, str]]:
        """Retorna lista de todos os proxies"""
        return self.proxies

    def add_proxy(self, proxy: str):
        """Adiciona um proxy à lista"""
        parsed = self._parse_proxy(proxy)
        if parsed:
            self.proxies.append(parsed)


class AuthManager:
    """Gerenciador de autenticação"""

    @staticmethod
    def create_basic_auth(username: str, password: str) -> HTTPBasicAuth:
        """Cria autenticação Basic"""
        return HTTPBasicAuth(username, password)

    @staticmethod
    def create_digest_auth(username: str, password: str) -> HTTPDigestAuth:
        """Cria autenticação Digest"""
        return HTTPDigestAuth(username, password)

    @staticmethod
    def create_bearer_header(token: str) -> Dict[str, str]:
        """Cria header de Bearer token"""
        return {'Authorization': f'Bearer {token}'}

    @staticmethod
    def create_api_key_header(api_key: str, header_name: str = 'X-API-Key') -> Dict[str, str]:
        """Cria header de API key"""
        return {header_name: api_key}

    @staticmethod
    def load_from_file(auth_file: str) -> Dict[str, str]:
        """
        Carrega credenciais de arquivo
        Formato JSON:
        {
            "type": "basic|bearer|api_key",
            "username": "user",
            "password": "pass",
            "token": "token_value",
            "api_key": "key_value"
        }
        """
        import json
        with open(auth_file, 'r') as f:
            return json.load(f)
