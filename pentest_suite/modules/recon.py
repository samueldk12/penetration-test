"""
Módulo de Reconhecimento
- Enumeração de subdomínios
- Port scanning
- Banner grabbing
- Detecção de tecnologias
"""

import socket
import ssl
import dns.resolver
import requests
import concurrent.futures
import subprocess
from typing import List, Dict, Set
from urllib.parse import urlparse
import re


class ReconModule:
    def __init__(self, target: str, timeout: int = 5):
        self.target = target
        self.timeout = timeout
        self.domain = self._extract_domain(target)
        self.subdomains = set()
        self.open_ports = []
        self.technologies = {}

    def _extract_domain(self, target: str) -> str:
        """Extrai o domínio de uma URL ou IP"""
        if target.startswith(('http://', 'https://')):
            parsed = urlparse(target)
            return parsed.netloc
        return target

    def subdomain_enumeration(self, wordlist: List[str] = None) -> Set[str]:
        """
        Enumera subdomínios usando:
        1. Brute force com wordlist
        2. DNS zone transfer (se disponível)
        3. Certificate transparency logs
        """
        print(f"[*] Enumerando subdomínios para {self.domain}...")

        if wordlist is None:
            # Wordlist básica comum
            wordlist = [
                'www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp',
                'pop', 'ns1', 'webdisk', 'ns2', 'cpanel', 'whm',
                'autodiscover', 'autoconfig', 'dev', 'staging', 'test',
                'api', 'admin', 'portal', 'blog', 'shop', 'vpn',
                'remote', 'server', 'cloud', 'backup', 'mysql', 'db'
            ]

        # Brute force DNS
        found_subdomains = self._dns_bruteforce(wordlist)

        # Certificate Transparency (via crt.sh)
        ct_subdomains = self._check_certificate_transparency()

        self.subdomains = found_subdomains.union(ct_subdomains)
        print(f"[+] Encontrados {len(self.subdomains)} subdomínios")

        return self.subdomains

    def _dns_bruteforce(self, wordlist: List[str]) -> Set[str]:
        """Brute force DNS para encontrar subdomínios"""
        found = set()
        resolver = dns.resolver.Resolver()
        resolver.timeout = self.timeout
        resolver.lifetime = self.timeout

        def check_subdomain(sub):
            subdomain = f"{sub}.{self.domain}"
            try:
                answers = resolver.resolve(subdomain, 'A')
                if answers:
                    print(f"[+] Subdomínio encontrado: {subdomain}")
                    return subdomain
            except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer,
                    dns.resolver.Timeout, dns.exception.DNSException):
                pass
            return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            results = executor.map(check_subdomain, wordlist)
            found = {r for r in results if r}

        return found

    def _check_certificate_transparency(self) -> Set[str]:
        """Consulta Certificate Transparency logs via crt.sh"""
        print("[*] Consultando Certificate Transparency logs...")
        found = set()

        try:
            url = f"https://crt.sh/?q=%.{self.domain}&output=json"
            response = requests.get(url, timeout=self.timeout)

            if response.status_code == 200:
                data = response.json()
                for entry in data:
                    name = entry.get('name_value', '')
                    # Remove wildcards e adiciona subdomínios
                    subdomains = name.split('\n')
                    for sub in subdomains:
                        sub = sub.strip().replace('*.', '')
                        if sub.endswith(self.domain) and sub != self.domain:
                            found.add(sub)
                            print(f"[+] CT Log: {sub}")
        except Exception as e:
            print(f"[-] Erro ao consultar CT logs: {e}")

        return found

    def port_scan(self, ports: List[int] = None, host: str = None) -> List[Dict]:
        """
        Escaneia portas comuns ou especificadas
        """
        if host is None:
            host = self.domain

        if ports is None:
            # Portas mais comuns
            ports = [
                21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
                993, 995, 1723, 3306, 3389, 5900, 8080, 8443, 8888
            ]

        print(f"[*] Escaneando {len(ports)} portas em {host}...")

        def check_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                result = sock.connect_ex((host, port))
                sock.close()

                if result == 0:
                    banner = self._grab_banner(host, port)
                    service = self._identify_service(port, banner)
                    print(f"[+] Porta aberta: {port}/tcp - {service}")
                    return {
                        'port': port,
                        'state': 'open',
                        'service': service,
                        'banner': banner
                    }
            except Exception as e:
                pass
            return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(check_port, ports)
            self.open_ports = [r for r in results if r]

        print(f"[+] Encontradas {len(self.open_ports)} portas abertas")
        return self.open_ports

    def _grab_banner(self, host: str, port: int) -> str:
        """Captura banner de serviço"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((host, port))

            # Tenta receber banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()

            # Para HTTP/HTTPS, faz uma requisição
            if port in [80, 443, 8080, 8443]:
                try:
                    protocol = 'https' if port in [443, 8443] else 'http'
                    response = requests.get(f"{protocol}://{host}:{port}",
                                          timeout=2, verify=False)
                    banner = f"HTTP {response.status_code} - {response.headers.get('Server', 'Unknown')}"
                except:
                    pass

            sock.close()
            return banner
        except:
            return ""

    def _identify_service(self, port: int, banner: str) -> str:
        """Identifica serviço baseado em porta e banner"""
        common_ports = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 445: 'SMB', 3306: 'MySQL', 3389: 'RDP',
            5900: 'VNC', 8080: 'HTTP-Proxy', 8443: 'HTTPS-Alt'
        }

        service = common_ports.get(port, 'Unknown')

        # Refina baseado no banner
        if banner:
            banner_lower = banner.lower()
            if 'ssh' in banner_lower:
                service = 'SSH'
            elif 'ftp' in banner_lower:
                service = 'FTP'
            elif 'http' in banner_lower or 'apache' in banner_lower or 'nginx' in banner_lower:
                service = 'HTTP/HTTPS'
            elif 'mysql' in banner_lower:
                service = 'MySQL'

        return service

    def detect_technologies(self, url: str = None) -> Dict:
        """
        Detecta tecnologias web usando:
        - Headers HTTP
        - Meta tags
        - JavaScript libraries
        - Cookies
        """
        if url is None:
            url = f"http://{self.domain}"

        print(f"[*] Detectando tecnologias em {url}...")
        technologies = {
            'server': None,
            'frameworks': [],
            'cms': None,
            'javascript_libs': [],
            'headers': {}
        }

        try:
            response = requests.get(url, timeout=self.timeout, verify=False)

            # Headers
            technologies['headers'] = dict(response.headers)
            technologies['server'] = response.headers.get('Server', 'Unknown')

            # Detecta X-Powered-By
            powered_by = response.headers.get('X-Powered-By')
            if powered_by:
                technologies['frameworks'].append(powered_by)

            # Analisa HTML
            html = response.text

            # Detecta CMS
            cms_patterns = {
                'WordPress': ['/wp-content/', '/wp-includes/', 'wordpress'],
                'Joomla': ['/components/com_', 'joomla'],
                'Drupal': ['/sites/default/', 'drupal'],
                'Magento': ['/skin/frontend/', 'mage'],
                'Shopify': ['cdn.shopify.com', 'shopify'],
            }

            for cms, patterns in cms_patterns.items():
                if any(pattern in html.lower() for pattern in patterns):
                    technologies['cms'] = cms
                    print(f"[+] CMS detectado: {cms}")
                    break

            # Detecta JavaScript libraries
            js_patterns = {
                'jQuery': r'jquery[.-](\d+\.\d+\.\d+)',
                'React': r'react[.-](\d+\.\d+\.\d+)',
                'Angular': r'angular[.-](\d+\.\d+\.\d+)',
                'Vue.js': r'vue[.-](\d+\.\d+\.\d+)',
                'Bootstrap': r'bootstrap[.-](\d+\.\d+\.\d+)',
            }

            for lib, pattern in js_patterns.items():
                match = re.search(pattern, html, re.IGNORECASE)
                if match:
                    version = match.group(1) if match.groups() else 'Unknown'
                    technologies['javascript_libs'].append(f"{lib} {version}")
                    print(f"[+] Biblioteca JS: {lib} {version}")

        except Exception as e:
            print(f"[-] Erro ao detectar tecnologias: {e}")

        self.technologies = technologies
        return technologies

    def get_full_report(self) -> Dict:
        """Retorna relatório completo do reconhecimento"""
        return {
            'target': self.target,
            'domain': self.domain,
            'subdomains': list(self.subdomains),
            'open_ports': self.open_ports,
            'technologies': self.technologies
        }
