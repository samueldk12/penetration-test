"""
Módulo para carregar arquivos (URLs, payloads, wordlists)
"""

from typing import List, Dict, Optional, Set
import os
import json


class FileLoader:
    """Classe para carregar diferentes tipos de arquivos"""

    @staticmethod
    def load_urls(file_path: str) -> List[str]:
        """
        Carrega lista de URLs de arquivo
        Formato: uma URL por linha
        Suporta comentários com #
        """
        urls = []

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")

        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # Ignora linhas vazias e comentários
                if line and not line.startswith('#'):
                    urls.append(line)

        print(f"[+] Carregadas {len(urls)} URLs de {file_path}")
        return urls

    @staticmethod
    def load_payloads(file_path: str) -> List[str]:
        """
        Carrega lista de payloads de arquivo
        Formato: um payload por linha
        Suporta comentários com #
        """
        payloads = []

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")

        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    payloads.append(line)

        print(f"[+] Carregados {len(payloads)} payloads de {file_path}")
        return payloads

    @staticmethod
    def load_wordlist(file_path: str) -> List[str]:
        """
        Carrega wordlist de arquivo
        Remove duplicatas e linhas vazias
        """
        words = set()

        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")

        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    words.add(line)

        word_list = sorted(list(words))
        print(f"[+] Carregadas {len(word_list)} palavras de {file_path}")
        return word_list

    @staticmethod
    def load_json_config(file_path: str) -> Dict:
        """
        Carrega arquivo JSON de configuração
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")

        with open(file_path, 'r', encoding='utf-8') as f:
            config = json.load(f)

        print(f"[+] Configuração carregada de {file_path}")
        return config

    @staticmethod
    def load_target_list(file_path: str) -> List[Dict[str, str]]:
        """
        Carrega lista de targets com metadados
        Formato JSON:
        [
            {
                "url": "https://example.com",
                "name": "Example Site",
                "priority": "high",
                "tests": ["sqli", "xss"]
            }
        ]
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")

        with open(file_path, 'r', encoding='utf-8') as f:
            targets = json.load(f)

        print(f"[+] Carregados {len(targets)} targets de {file_path}")
        return targets

    @staticmethod
    def save_results(file_path: str, data: Dict):
        """
        Salva resultados em arquivo JSON
        """
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        print(f"[+] Resultados salvos em {file_path}")


class PayloadManager:
    """Gerenciador de payloads customizados"""

    def __init__(self):
        self.payloads: Dict[str, List[str]] = {
            'sqli': [],
            'xss': [],
            'command_injection': [],
            'path_traversal': [],
            'xxe': [],
            'ssrf': [],
            'ldap': [],
            'prompt_injection': [],
            'jailbreak': [],
        }

    def load_category(self, category: str, file_path: str):
        """Carrega payloads para uma categoria específica"""
        if category not in self.payloads:
            self.payloads[category] = []

        payloads = FileLoader.load_payloads(file_path)
        self.payloads[category].extend(payloads)

        print(f"[+] Categoria '{category}': {len(self.payloads[category])} payloads")

    def load_all_from_directory(self, directory: str):
        """
        Carrega todos os payloads de um diretório
        Espera arquivos nomeados como: sqli.txt, xss.txt, etc.
        """
        if not os.path.exists(directory):
            print(f"[-] Diretório não encontrado: {directory}")
            return

        for category in self.payloads.keys():
            file_path = os.path.join(directory, f"{category}.txt")
            if os.path.exists(file_path):
                self.load_category(category, file_path)

    def get_payloads(self, category: str) -> List[str]:
        """Retorna payloads de uma categoria"""
        return self.payloads.get(category, [])

    def add_payload(self, category: str, payload: str):
        """Adiciona um payload a uma categoria"""
        if category not in self.payloads:
            self.payloads[category] = []

        self.payloads[category].append(payload)

    def get_all_categories(self) -> List[str]:
        """Retorna todas as categorias disponíveis"""
        return list(self.payloads.keys())


class TargetManager:
    """Gerenciador de targets"""

    def __init__(self):
        self.targets: List[Dict] = []

    def load_from_file(self, file_path: str):
        """Carrega targets de arquivo"""
        self.targets = FileLoader.load_target_list(file_path)

    def load_simple_urls(self, file_path: str):
        """Carrega lista simples de URLs"""
        urls = FileLoader.load_urls(file_path)
        self.targets = [{'url': url} for url in urls]

    def add_target(self, url: str, **kwargs):
        """Adiciona um target"""
        target = {'url': url}
        target.update(kwargs)
        self.targets.append(target)

    def get_targets(self, filter_by: Optional[Dict] = None) -> List[Dict]:
        """
        Retorna targets, opcionalmente filtrados
        Exemplo: filter_by={'priority': 'high'}
        """
        if not filter_by:
            return self.targets

        filtered = []
        for target in self.targets:
            match = all(target.get(k) == v for k, v in filter_by.items())
            if match:
                filtered.append(target)

        return filtered

    def get_urls(self) -> List[str]:
        """Retorna apenas as URLs"""
        return [t['url'] for t in self.targets]


class TestSelector:
    """Seletor de testes específicos"""

    AVAILABLE_TESTS = {
        # Web vulnerabilities
        'sqli': 'SQL Injection',
        'xss': 'Cross-Site Scripting',
        'command_injection': 'Command Injection',
        'path_traversal': 'Path Traversal',
        'idor': 'Insecure Direct Object Reference',
        'ssrf': 'Server-Side Request Forgery',
        'xxe': 'XML External Entity',
        'csrf': 'Cross-Site Request Forgery',
        'cors': 'CORS Misconfiguration',
        'open_redirect': 'Open Redirect',

        # LLM vulnerabilities
        'prompt_injection': 'Prompt Injection',
        'jailbreak': 'Jailbreak Attempts',
        'system_prompt_leak': 'System Prompt Extraction',
        'pii_leak': 'PII Leakage',
        'training_data_leak': 'Training Data Extraction',
        'llm_dos': 'LLM Denial of Service',

        # Recon
        'subdomain_enum': 'Subdomain Enumeration',
        'port_scan': 'Port Scanning',
        'tech_detect': 'Technology Detection',

        # Discovery
        'crawl': 'Web Crawling',
        'directory_bruteforce': 'Directory Bruteforce',
        'api_discovery': 'API Discovery',
    }

    def __init__(self, selected_tests: Optional[List[str]] = None):
        self.selected_tests = set(selected_tests) if selected_tests else set()

    def load_from_file(self, file_path: str):
        """
        Carrega lista de testes de arquivo
        Formato: um teste por linha
        """
        tests = FileLoader.load_payloads(file_path)
        self.selected_tests = set(tests)

        print(f"[+] Selecionados {len(self.selected_tests)} testes")

    def add_test(self, test_name: str):
        """Adiciona um teste"""
        if test_name in self.AVAILABLE_TESTS:
            self.selected_tests.add(test_name)
        else:
            print(f"[-] Teste desconhecido: {test_name}")
            print(f"[*] Testes disponíveis: {', '.join(self.AVAILABLE_TESTS.keys())}")

    def should_run(self, test_name: str) -> bool:
        """Verifica se um teste deve ser executado"""
        # Se nenhum teste foi selecionado, executa todos
        if not self.selected_tests:
            return True

        return test_name in self.selected_tests

    def get_selected_tests(self) -> List[str]:
        """Retorna lista de testes selecionados"""
        return list(self.selected_tests)

    def list_available_tests(self):
        """Lista todos os testes disponíveis"""
        print("\n[*] Testes disponíveis:")
        print("=" * 80)

        categories = {
            'Web Vulnerabilities': ['sqli', 'xss', 'command_injection', 'path_traversal',
                                   'idor', 'ssrf', 'xxe', 'csrf', 'cors', 'open_redirect'],
            'LLM Vulnerabilities': ['prompt_injection', 'jailbreak', 'system_prompt_leak',
                                   'pii_leak', 'training_data_leak', 'llm_dos'],
            'Reconnaissance': ['subdomain_enum', 'port_scan', 'tech_detect'],
            'Discovery': ['crawl', 'directory_bruteforce', 'api_discovery'],
        }

        for category, tests in categories.items():
            print(f"\n{category}:")
            for test in tests:
                print(f"  - {test}: {self.AVAILABLE_TESTS[test]}")
