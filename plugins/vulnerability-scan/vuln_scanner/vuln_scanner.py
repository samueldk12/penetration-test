#!/usr/bin/env python3
"""
Vulnerability Scanner Plugin
Basic vulnerability scanning for common web vulnerabilities
"""

import sys
import json
import requests
import re
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(project_root / 'tools'))

from tools.plugin_system import PluginInterface


class VulnScannerPlugin(PluginInterface):
    """Plugin para escaneamento básico de vulnerabilidades."""

    name = "vuln_scanner"
    version = "1.0.0"
    author = "Penetration Test Suite"
    description = "Basic vulnerability scanner for common web vulnerabilities"
    category = "vuln_scan"
    requires = ["requests", "beautifulsoup4"]

    def __init__(self, config=None):
        super().__init__(config)
        self.session = requests.Session()
        self.session.verify = False
        requests.packages.urllib3.disable_warnings()

    def run(self, target: str, **kwargs):
        """
        Executa escaneamento de vulnerabilidades no alvo.

        Args:
            target: URL do alvo
            **kwargs: Opções adicionais

        Returns:
            Dict com resultados do scan
        """
        print(f"\n[*] Starting Vulnerability Scan on: {target}")
        print("=" * 60)

        # Ensure target has a scheme
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"

        # Options
        check_xss = kwargs.get('check_xss', True)
        check_sqli = kwargs.get('check_sqli', True)
        check_headers = kwargs.get('check_headers', True)
        check_ssl = kwargs.get('check_ssl', True)
        check_cors = kwargs.get('check_cors', True)
        timeout = kwargs.get('timeout', 10)

        results = {
            'plugin': self.name,
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'security_issues': [],
            'info': []
        }

        try:
            # 1. Check Security Headers
            if check_headers:
                print("\n[*] Checking Security Headers...")
                print("-" * 60)
                header_issues = self._check_security_headers(target, timeout)
                results['security_issues'].extend(header_issues)

            # 2. Check CORS Configuration
            if check_cors:
                print("\n[*] Checking CORS Configuration...")
                print("-" * 60)
                cors_issues = self._check_cors(target, timeout)
                if cors_issues:
                    results['vulnerabilities'].extend(cors_issues)

            # 3. Check for SQL Injection (basic)
            if check_sqli:
                print("\n[*] Checking for SQL Injection (basic)...")
                print("-" * 60)
                sqli_issues = self._check_sqli_basic(target, timeout)
                if sqli_issues:
                    results['vulnerabilities'].extend(sqli_issues)

            # 4. Check for XSS (basic)
            if check_xss:
                print("\n[*] Checking for XSS (basic)...")
                print("-" * 60)
                xss_issues = self._check_xss_basic(target, timeout)
                if xss_issues:
                    results['vulnerabilities'].extend(xss_issues)

            # 5. SSL/TLS Check
            if check_ssl and target.startswith('https://'):
                print("\n[*] Checking SSL/TLS Configuration...")
                print("-" * 60)
                ssl_issues = self._check_ssl_config(target)
                if ssl_issues:
                    results['info'].extend(ssl_issues)

            # Generate summary
            print("\n" + "=" * 60)
            print("VULNERABILITY SCAN SUMMARY")
            print("=" * 60)
            print(f"Target:              {target}")
            print(f"Vulnerabilities:     {len(results['vulnerabilities'])}")
            print(f"Security Issues:     {len(results['security_issues'])}")
            print(f"Info:                {len(results['info'])}")
            print("=" * 60)

            # Print critical findings
            high_vulns = [v for v in results['vulnerabilities'] if v.get('severity') == 'high']
            if high_vulns:
                print("\n⚠️  HIGH SEVERITY VULNERABILITIES:")
                for vuln in high_vulns:
                    print(f"  - {vuln['title']}")

            self.results.append(results)
            return results

        except Exception as e:
            error_msg = f"Vulnerability scan failed: {str(e)}"
            print(f"[!] {error_msg}")
            self.errors.append(error_msg)

            return {
                'plugin': self.name,
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'error': error_msg
            }

    def _check_security_headers(self, target, timeout):
        """Check for missing or misconfigured security headers."""
        issues = []

        try:
            response = self.session.get(target, timeout=timeout)
            headers = response.headers

            # Required security headers
            security_headers = {
                'X-Frame-Options': 'Protects against clickjacking',
                'X-Content-Type-Options': 'Prevents MIME-sniffing',
                'X-XSS-Protection': 'Enables XSS filter',
                'Strict-Transport-Security': 'Enforces HTTPS',
                'Content-Security-Policy': 'Prevents XSS and injection attacks'
            }

            for header, description in security_headers.items():
                if header not in headers:
                    issues.append({
                        'type': 'missing_security_header',
                        'severity': 'medium',
                        'header': header,
                        'description': f'Missing {header} header',
                        'impact': description
                    })
                    print(f"  [-] Missing: {header}")
                else:
                    print(f"  [+] Present: {header} = {headers[header]}")

            # Check for sensitive information disclosure
            if 'Server' in headers:
                issues.append({
                    'type': 'information_disclosure',
                    'severity': 'low',
                    'header': 'Server',
                    'value': headers['Server'],
                    'description': 'Server header reveals software version'
                })

            if 'X-Powered-By' in headers:
                issues.append({
                    'type': 'information_disclosure',
                    'severity': 'low',
                    'header': 'X-Powered-By',
                    'value': headers['X-Powered-By'],
                    'description': 'X-Powered-By header reveals technology stack'
                })

        except Exception as e:
            print(f"  [!] Error checking headers: {e}")

        return issues

    def _check_cors(self, target, timeout):
        """Check CORS configuration."""
        issues = []

        try:
            headers = {'Origin': 'https://evil.com'}
            response = self.session.get(target, headers=headers, timeout=timeout)

            cors_header = response.headers.get('Access-Control-Allow-Origin')
            creds_header = response.headers.get('Access-Control-Allow-Credentials')

            if cors_header == '*' and creds_header == 'true':
                issues.append({
                    'type': 'cors_misconfiguration',
                    'severity': 'high',
                    'title': 'Dangerous CORS configuration',
                    'description': 'CORS allows any origin (*) with credentials enabled',
                    'impact': 'Attackers can steal sensitive data from authenticated users'
                })
                print("  [!] HIGH: Dangerous CORS configuration detected!")

            elif cors_header == 'https://evil.com':
                issues.append({
                    'type': 'cors_misconfiguration',
                    'severity': 'high',
                    'title': 'CORS reflects arbitrary origins',
                    'description': 'Server reflects the Origin header without validation',
                    'impact': 'Attackers can bypass same-origin policy'
                })
                print("  [!] HIGH: CORS reflects arbitrary origins!")
            else:
                print("  [+] CORS configuration appears secure")

        except Exception as e:
            print(f"  [!] Error checking CORS: {e}")

        return issues

    def _check_sqli_basic(self, target, timeout):
        """Basic SQL injection check."""
        issues = []

        # Add query parameter if not present
        test_url = target if '?' in target else f"{target}?id=1"

        sqli_payloads = [
            "'", "\"", "' OR '1'='1", "1' AND '1'='1",
            "' OR 1=1--", "admin'--", "1' UNION SELECT NULL--"
        ]

        sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.* SQL[-_ ]*Server",
            r"OLE DB.* SQL Server",
            r"SQLServer JDBC Driver",
            r"SqlClient\.",
            r"Microsoft SQL Native Client",
            r"Unclosed quotation mark",
            r"quoted string not properly terminated"
        ]

        for payload in sqli_payloads[:3]:  # Test only first 3 to be quick
            try:
                parsed = urlparse(test_url)
                inject_url = test_url.replace('id=1', f'id={payload}')

                response = self.session.get(inject_url, timeout=timeout)

                for error_pattern in sql_errors:
                    if re.search(error_pattern, response.text, re.IGNORECASE):
                        issues.append({
                            'type': 'sql_injection',
                            'severity': 'high',
                            'title': 'Possible SQL Injection',
                            'payload': payload,
                            'url': inject_url,
                            'description': f'SQL error detected with payload: {payload}',
                            'evidence': error_pattern
                        })
                        print(f"  [!] HIGH: Possible SQLi with payload: {payload}")
                        return issues  # Return on first finding

            except Exception:
                pass

        if not issues:
            print("  [+] No obvious SQL injection detected")

        return issues

    def _check_xss_basic(self, target, timeout):
        """Basic XSS check."""
        issues = []

        # Add query parameter if not present
        test_url = target if '?' in target else f"{target}?q=test"

        xss_payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "javascript:alert(1)"
        ]

        for payload in xss_payloads[:2]:  # Test only first 2 to be quick
            try:
                inject_url = test_url.replace('q=test', f'q={payload}')
                response = self.session.get(inject_url, timeout=timeout)

                if payload in response.text:
                    issues.append({
                        'type': 'xss',
                        'severity': 'high',
                        'title': 'Possible Reflected XSS',
                        'payload': payload,
                        'url': inject_url,
                        'description': f'Payload reflected in response: {payload}'
                    })
                    print(f"  [!] HIGH: Possible XSS - payload reflected")
                    return issues  # Return on first finding

            except Exception:
                pass

        if not issues:
            print("  [+] No obvious XSS detected")

        return issues

    def _check_ssl_config(self, target):
        """Check SSL/TLS configuration."""
        issues = []

        try:
            parsed = urlparse(target)
            domain = parsed.netloc

            # Try to get SSL info
            import ssl
            import socket

            context = ssl.create_default_context()
            with socket.create_connection((domain, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    protocol = ssock.version()

                    issues.append({
                        'type': 'ssl_info',
                        'severity': 'info',
                        'title': 'SSL/TLS Protocol',
                        'protocol': protocol,
                        'description': f'Server uses {protocol}'
                    })

                    print(f"  [+] SSL/TLS Protocol: {protocol}")

                    # Warn about old protocols
                    if protocol in ['TLSv1', 'TLSv1.1', 'SSLv3', 'SSLv2']:
                        issues.append({
                            'type': 'weak_ssl',
                            'severity': 'high',
                            'title': 'Weak SSL/TLS Protocol',
                            'protocol': protocol,
                            'description': f'Server supports outdated protocol: {protocol}'
                        })
                        print(f"  [!] HIGH: Outdated protocol {protocol}")

        except Exception as e:
            print(f"  [!] Error checking SSL: {e}")

        return issues


# For direct testing
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python3 vuln_scanner.py <target>")
        sys.exit(1)

    target = sys.argv[1]
    plugin = VulnScannerPlugin()

    results = plugin.run(target)

    print("\n" + "=" * 60)
    print("RESULTS")
    print("=" * 60)
    print(json.dumps(results, indent=2))
