#!/usr/bin/env python3
"""
Auto Pentest - Sistema completo automatizado
Integra: reconnaissance → URL discovery → secret scanning → vulnerability testing → storage
"""

import sys
import json
import time
from typing import Dict, List, Optional
from pathlib import Path

# Import componentes
from plugin_system import PluginManager
from recon_integration import ReconIntegration
from discovery_storage import DiscoveryDatabase
from secret_scanner import SecretScanner


class AutoPentest:
    """Sistema completo de pentest automatizado."""

    def __init__(self, target: str, db_path: str = "auto_pentest.db"):
        self.target = target
        self.db_path = db_path

        # Initialize components
        self.db = DiscoveryDatabase(db_path)
        self.recon = ReconIntegration(db_path)
        self.scanner = SecretScanner()
        self.plugin_manager = PluginManager(plugins_dir="plugins")

        # Discover plugins
        plugin_count = self.plugin_manager.discover_plugins()
        print(f"[+] Loaded {plugin_count} plugins")

        # Statistics
        self.stats = {
            'start_time': time.time(),
            'subdomains': 0,
            'urls': 0,
            'secrets': 0,
            'vulnerabilities': 0,
            'high_risk_vulns': 0
        }

    # ============================================
    # FASE 1: RECONNAISSANCE & URL DISCOVERY
    # ============================================

    def phase_1_reconnaissance(self) -> Dict:
        """
        Fase 1: Reconnaissance completo.

        Returns:
            Dicionário com URLs descobertas
        """
        print("\n" + "=" * 60)
        print("FASE 1: RECONNAISSANCE & URL DISCOVERY")
        print("=" * 60)

        all_urls = set()
        all_subdomains = set()

        # 1.1: Subdomain discovery (auto_recon.py já faz isso)
        print("\n[1.1] Subdomain Discovery")
        print("-" * 60)
        print(f"[*] Target: {self.target}")
        print(f"[*] Running automated subdomain discovery...")

        # Aqui você rodaria auto_recon.py ou recon_wrapper.py
        # Por ora, simula com alguns subdomínios
        subdomains = [
            self.target,
            f"www.{self.target}",
            f"api.{self.target}",
            f"dev.{self.target}"
        ]

        for sub in subdomains:
            self.db.add_subdomain(sub, self.target, discovered_by='auto_pentest')
            all_subdomains.add(sub)

        self.stats['subdomains'] = len(all_subdomains)
        print(f"[+] Discovered {len(all_subdomains)} subdomains")

        # 1.2: Wayback Machine (plugin)
        print("\n[1.2] Historical URLs (Wayback Machine)")
        print("-" * 60)

        wayback_plugin = self.plugin_manager.get_plugin('wayback_urls')
        if wayback_plugin:
            result = wayback_plugin.run(self.target, limit=500)

            if 'urls' in result:
                wayback_urls = result['urls']
                print(f"[+] Found {len(wayback_urls)} historical URLs")

                for url in wayback_urls:
                    all_urls.add(url)

                    # Store in database
                    from urllib.parse import urlparse
                    parsed = urlparse(url)
                    self.db.add_url(
                        url=url,
                        domain=parsed.netloc,
                        discovered_by='wayback_machine'
                    )

        # 1.3: GitHub dorking (plugin)
        print("\n[1.3] GitHub Reconnaissance")
        print("-" * 60)

        github_plugin = self.plugin_manager.get_plugin('github_dorking')
        if github_plugin:
            result = github_plugin.run(self.target)

            if 'findings' in result:
                github_findings = result['findings']
                print(f"[+] Found {len(github_findings)} GitHub results")

                # Extract URLs from findings
                for finding in github_findings:
                    url = finding.get('url', '')
                    if url:
                        all_urls.add(url)

        self.stats['urls'] = len(all_urls)

        print(f"\n[+] Phase 1 Complete: {len(all_urls)} total URLs discovered")

        return {
            'urls': list(all_urls),
            'subdomains': list(all_subdomains)
        }

    # ============================================
    # FASE 2: SECRET SCANNING
    # ============================================

    def phase_2_secret_scanning(self, urls: List[str]) -> Dict:
        """
        Fase 2: Secret scanning em todas as URLs.

        Args:
            urls: Lista de URLs para escanear

        Returns:
            Dicionário com secrets encontradas
        """
        print("\n" + "=" * 60)
        print("FASE 2: SECRET SCANNING")
        print("=" * 60)

        all_secrets = []

        print(f"[*] Scanning {len(urls)} URLs for secrets...")

        # Limita para não demorar muito
        for i, url in enumerate(urls[:50], 1):
            if i % 10 == 0:
                print(f"[*] Progress: {i}/{min(len(urls), 50)}")

            try:
                import requests
                response = requests.get(url, timeout=5, verify=False)

                # Escaneia response
                findings = self.scanner.scan_url_response(
                    url=url,
                    response_text=response.text,
                    response_headers=dict(response.headers)
                )

                if findings:
                    print(f"[!] {len(findings)} secrets found in {url}")

                    for finding in findings:
                        # Store in database
                        secret_id = self.db.add_secret(
                            secret_value=finding['value'],
                            secret_type=finding['type'],
                            url=url,
                            service=finding['service'],
                            risk_level=finding['risk_level'],
                            discovered_by='auto_pentest'
                        )

                        all_secrets.append(finding)

            except:
                pass

        self.stats['secrets'] = len(all_secrets)
        print(f"\n[+] Phase 2 Complete: {len(all_secrets)} secrets found")

        return {'secrets': all_secrets}

    # ============================================
    # FASE 3: CLOUD VULNERABILITY TESTING
    # ============================================

    def phase_3_cloud_testing(self, secrets: List[Dict]) -> Dict:
        """
        Fase 3: Testa vulnerabilidades em cloud keys descobertas.

        Args:
            secrets: Lista de secrets encontradas

        Returns:
            Dicionário com vulnerabilidades
        """
        print("\n" + "=" * 60)
        print("FASE 3: CLOUD VULNERABILITY TESTING")
        print("=" * 60)

        cloud_plugin = self.plugin_manager.get_plugin('cloud_vuln_tester')
        if not cloud_plugin:
            print("[!] Cloud vulnerability tester plugin not loaded")
            return {'vulnerabilities': []}

        all_vulns = []

        # Filtra cloud secrets
        cloud_secrets = [s for s in secrets if s['service'] in ['aws', 'gcp', 'azure']]

        print(f"[*] Found {len(cloud_secrets)} cloud credentials to test")

        for secret in cloud_secrets:
            service = secret['service']
            secret_type = secret['type']

            print(f"\n[*] Testing {service.upper()} - {secret_type}")

            # Aqui você precisaria extrair as credenciais completas
            # Por ora, demonstra o conceito

            try:
                result = cloud_plugin.run(
                    target=service,
                    service=service,
                    credentials={}  # Credentials extraídas da secret
                )

                if 'vulnerabilities' in result:
                    vulns = result['vulnerabilities']

                    if vulns:
                        print(f"[!] Found {len(vulns)} vulnerabilities!")
                        all_vulns.extend(vulns)

                        # Count high risk
                        high_risk = [v for v in vulns if v.get('severity') in ['critical', 'high']]
                        self.stats['high_risk_vulns'] += len(high_risk)

            except Exception as e:
                print(f"[!] Error testing {service}: {e}")

        self.stats['vulnerabilities'] = len(all_vulns)
        print(f"\n[+] Phase 3 Complete: {len(all_vulns)} vulnerabilities found")

        return {'vulnerabilities': all_vulns}

    # ============================================
    # FASE 4: WEB VULNERABILITY SCANNING
    # ============================================

    def phase_4_web_vuln_scanning(self, urls: List[str]) -> Dict:
        """
        Fase 4: Escaneia vulnerabilidades web (XSS, SQLi).

        Args:
            urls: Lista de URLs

        Returns:
            Dicionário com vulnerabilidades
        """
        print("\n" + "=" * 60)
        print("FASE 4: WEB VULNERABILITY SCANNING")
        print("=" * 60)

        all_vulns = []

        # XSS Scanner
        xss_plugin = self.plugin_manager.get_plugin('xss_scanner')
        if xss_plugin:
            print("\n[4.1] XSS Vulnerability Scanning")
            print("-" * 60)

            # Testa primeiras 10 URLs com parâmetros
            test_urls = [url for url in urls if '?' in url][:10]

            print(f"[*] Testing {len(test_urls)} URLs for XSS...")

            for url in test_urls:
                result = xss_plugin.run(url)

                if result.get('count', 0) > 0:
                    vulns = result.get('vulnerabilities', [])
                    all_vulns.extend(vulns)
                    self.stats['vulnerabilities'] += len(vulns)

        # SQLi Scanner
        sqli_plugin = self.plugin_manager.get_plugin('sqli_scanner')
        if sqli_plugin:
            print("\n[4.2] SQL Injection Scanning")
            print("-" * 60)

            # Testa primeiras 10 URLs com parâmetros
            test_urls = [url for url in urls if '?' in url][:10]

            print(f"[*] Testing {len(test_urls)} URLs for SQLi...")

            for url in test_urls:
                result = sqli_plugin.run(url)

                if result.get('count', 0) > 0:
                    vulns = result.get('vulnerabilities', [])
                    all_vulns.extend(vulns)
                    self.stats['vulnerabilities'] += len(vulns)

                    # SQLi is always high risk
                    self.stats['high_risk_vulns'] += len(vulns)

        print(f"\n[+] Phase 4 Complete: {len(all_vulns)} web vulnerabilities found")

        return {'vulnerabilities': all_vulns}

    # ============================================
    # MAIN WORKFLOW
    # ============================================

    def run(self) -> Dict:
        """
        Executa pentest completo automatizado.

        Returns:
            Relatório final
        """
        print("\n" + "=" * 60)
        print(f"AUTO PENTEST - {self.target}")
        print("=" * 60)

        # FASE 1: Reconnaissance
        recon_results = self.phase_1_reconnaissance()
        urls = recon_results['urls']

        # FASE 2: Secret Scanning
        secret_results = self.phase_2_secret_scanning(urls)
        secrets = secret_results['secrets']

        # FASE 3: Cloud Vulnerability Testing
        cloud_results = self.phase_3_cloud_testing(secrets)

        # FASE 4: Web Vulnerability Scanning
        web_results = self.phase_4_web_vuln_scanning(urls)

        # Generate final report
        elapsed_time = time.time() - self.stats['start_time']

        print("\n" + "=" * 60)
        print("PENTEST COMPLETO!")
        print("=" * 60)
        print(f"Tempo total: {elapsed_time:.2f}s")
        print(f"\nEstatísticas:")
        print(f"  Subdomínios: {self.stats['subdomains']}")
        print(f"  URLs: {self.stats['urls']}")
        print(f"  Secrets: {self.stats['secrets']}")
        print(f"  Vulnerabilidades: {self.stats['vulnerabilities']}")
        print(f"    └─ Alto risco: {self.stats['high_risk_vulns']}")
        print("=" * 60)

        # Gera relatório JSON
        report = {
            'target': self.target,
            'elapsed_time': elapsed_time,
            'statistics': self.stats,
            'reconnaissance': recon_results,
            'secrets': secret_results,
            'cloud_vulnerabilities': cloud_results,
            'web_vulnerabilities': web_results
        }

        report_file = f"auto_pentest_{self.target.replace('.', '_')}.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        print(f"\n[+] Relatório salvo em: {report_file}")
        print(f"[+] Banco de dados: {self.db_path}")

        return report

    def close(self):
        """Fecha conexões."""
        self.db.close()
        self.recon.close()


# CLI Interface
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Auto Pentest - Sistema completo automatizado",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Executa pentest completo automatizado:
  1. Reconnaissance (subdomains, URLs históricas, GitHub)
  2. Secret scanning (50+ padrões)
  3. Cloud vulnerability testing (AWS, GCP, Azure)
  4. Web vulnerability scanning (XSS, SQLi)

Exemplo:
  python auto_pentest.py example.com
  python auto_pentest.py example.com --db custom.db -o report.json
        """
    )

    parser.add_argument('target', help='Domínio alvo')
    parser.add_argument('--db', default='auto_pentest.db', help='Banco SQLite')
    parser.add_argument('-o', '--output', help='Arquivo JSON de saída')

    args = parser.parse_args()

    # Valida domínio
    import re
    domain = args.target.lower().strip()
    if not re.match(r'^[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,}$', domain):
        print(f"[!] Erro: Domínio inválido: {domain}")
        sys.exit(1)

    # Executa
    pentest = AutoPentest(target=domain, db_path=args.db)

    try:
        report = pentest.run()

        # Salva output se especificado
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(report, f, indent=2, default=str)
            print(f"\n[+] Relatório adicional salvo em: {args.output}")

    except KeyboardInterrupt:
        print("\n[!] Interrompido pelo usuário")
    except Exception as e:
        print(f"\n[!] Erro: {e}")
        import traceback
        traceback.print_exc()
    finally:
        pentest.close()
