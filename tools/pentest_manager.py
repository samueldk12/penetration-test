#!/usr/bin/env python3
"""
Penetration Testing Tools Manager
Integrates and manages various pentesting tools
"""

import subprocess
import json
import os
import shutil
from urllib.parse import urlparse
from utils.logger import get_logger


class PentestManager:
    """Manage and execute various penetration testing tools"""

    def __init__(self, settings):
        self.settings = settings
        self.logger = get_logger()
        self.available_tools = self._detect_available_tools()

    def _detect_available_tools(self):
        """Detect which pentesting tools are installed"""
        tools = {
            'nmap': shutil.which('nmap'),
            'sqlmap': shutil.which('sqlmap'),
            'nikto': shutil.which('nikto'),
            'dirb': shutil.which('dirb'),
            'dirbuster': shutil.which('dirbuster'),
            'wpscan': shutil.which('wpscan'),
            'whatweb': shutil.which('whatweb'),
            'wafw00f': shutil.which('wafw00f'),
            'sslyze': shutil.which('sslyze'),
            'testssl': shutil.which('testssl.sh'),
            'amass': shutil.which('amass'),
            'subfinder': shutil.which('subfinder'),
            'nuclei': shutil.which('nuclei'),
            'gobuster': shutil.which('gobuster'),
            'ffuf': shutil.which('ffuf'),
            'hydra': shutil.which('hydra'),
            'metasploit': shutil.which('msfconsole'),
            'burpsuite': shutil.which('burpsuite'),
            'zaproxy': shutil.which('zap-cli'),
        }

        available = {k: v for k, v in tools.items() if v}
        self.logger.info(f"Available tools: {', '.join(available.keys())}")

        return available

    def run_all_tools(self, target):
        """Run all available tools on target"""
        results = {}

        # Parse target
        parsed = urlparse(target)
        domain = parsed.netloc or parsed.path

        # Network scanning
        if 'nmap' in self.available_tools:
            results['nmap'] = self.run_nmap(domain)

        # Web vulnerability scanning
        if target.startswith('http'):
            if 'nikto' in self.available_tools:
                results['nikto'] = self.run_nikto(target)

            if 'whatweb' in self.available_tools:
                results['whatweb'] = self.run_whatweb(target)

            if 'wafw00f' in self.available_tools:
                results['wafw00f'] = self.run_wafw00f(target)

            if 'nuclei' in self.available_tools:
                results['nuclei'] = self.run_nuclei(target)

            # Directory brute forcing
            if 'gobuster' in self.available_tools:
                results['gobuster'] = self.run_gobuster(target)
            elif 'dirb' in self.available_tools:
                results['dirb'] = self.run_dirb(target)

            # SSL/TLS testing
            if 'testssl' in self.available_tools:
                results['testssl'] = self.run_testssl(target)
            elif 'sslyze' in self.available_tools:
                results['sslyze'] = self.run_sslyze(target)

            # WordPress scanning
            if 'wpscan' in self.available_tools:
                results['wpscan'] = self.run_wpscan(target)

        # Subdomain enumeration
        if 'subfinder' in self.available_tools:
            results['subfinder'] = self.run_subfinder(domain)
        elif 'amass' in self.available_tools:
            results['amass'] = self.run_amass(domain)

        return results

    def run_comprehensive_test(self, target):
        """Run comprehensive penetration test"""
        self.logger.info(f"Running comprehensive pentest on: {target}")

        results = {
            'target': target,
            'reconnaissance': {},
            'vulnerability_scanning': {},
            'exploitation': {},
            'post_exploitation': {}
        }

        # Reconnaissance phase
        results['reconnaissance'] = self._run_reconnaissance(target)

        # Vulnerability scanning
        results['vulnerability_scanning'] = self._run_vulnerability_scan(target)

        # Note: Exploitation and post-exploitation would be done manually
        # or with explicit authorization

        return results

    def _run_reconnaissance(self, target):
        """Run reconnaissance tools"""
        recon_results = {}

        parsed = urlparse(target)
        domain = parsed.netloc or parsed.path

        # Network reconnaissance
        if 'nmap' in self.available_tools:
            recon_results['nmap'] = self.run_nmap(domain)

        # Web reconnaissance
        if target.startswith('http'):
            if 'whatweb' in self.available_tools:
                recon_results['whatweb'] = self.run_whatweb(target)

        # Subdomain enumeration
        if 'subfinder' in self.available_tools:
            recon_results['subfinder'] = self.run_subfinder(domain)

        return recon_results

    def _run_vulnerability_scan(self, target):
        """Run vulnerability scanning tools"""
        vuln_results = {}

        if not target.startswith('http'):
            return vuln_results

        # Web vulnerabilities
        if 'nikto' in self.available_tools:
            vuln_results['nikto'] = self.run_nikto(target)

        if 'nuclei' in self.available_tools:
            vuln_results['nuclei'] = self.run_nuclei(target)

        # WAF detection
        if 'wafw00f' in self.available_tools:
            vuln_results['wafw00f'] = self.run_wafw00f(target)

        return vuln_results

    # Individual tool runners

    def run_nmap(self, target, options='-sV -sC -T4'):
        """Run Nmap scan"""
        self.logger.info(f"Running Nmap on {target}")

        try:
            cmd = f"nmap {options} {target}"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )

            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'tool': 'nmap'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'nmap'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'nmap'}

    def run_nikto(self, target):
        """Run Nikto web scanner"""
        self.logger.info(f"Running Nikto on {target}")

        try:
            cmd = f"nikto -h {target} -Format json -output /tmp/nikto_output.json"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            # Try to read JSON output
            output_data = result.stdout
            if os.path.exists('/tmp/nikto_output.json'):
                with open('/tmp/nikto_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/nikto_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'nikto'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'nikto'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'nikto'}

    def run_sqlmap(self, target, options='--batch --risk=1 --level=1'):
        """Run SQLmap"""
        self.logger.info(f"Running SQLmap on {target}")

        try:
            cmd = f"sqlmap -u {target} {options}"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=900
            )

            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'tool': 'sqlmap'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'sqlmap'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'sqlmap'}

    def run_whatweb(self, target):
        """Run WhatWeb"""
        self.logger.info(f"Running WhatWeb on {target}")

        try:
            cmd = f"whatweb {target} --log-json=/tmp/whatweb_output.json"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=120
            )

            output_data = result.stdout
            if os.path.exists('/tmp/whatweb_output.json'):
                with open('/tmp/whatweb_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/whatweb_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'whatweb'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'whatweb'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'whatweb'}

    def run_wafw00f(self, target):
        """Run wafw00f (WAF detection)"""
        self.logger.info(f"Running wafw00f on {target}")

        try:
            cmd = f"wafw00f {target} -o /tmp/wafw00f_output.json -f json"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=120
            )

            output_data = result.stdout
            if os.path.exists('/tmp/wafw00f_output.json'):
                with open('/tmp/wafw00f_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/wafw00f_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'wafw00f'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'wafw00f'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'wafw00f'}

    def run_nuclei(self, target):
        """Run Nuclei vulnerability scanner"""
        self.logger.info(f"Running Nuclei on {target}")

        try:
            cmd = f"nuclei -u {target} -json -o /tmp/nuclei_output.json"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            output_data = result.stdout
            if os.path.exists('/tmp/nuclei_output.json'):
                with open('/tmp/nuclei_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/nuclei_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'nuclei'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'nuclei'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'nuclei'}

    def run_gobuster(self, target, wordlist='/usr/share/wordlists/dirb/common.txt'):
        """Run Gobuster directory brute forcing"""
        self.logger.info(f"Running Gobuster on {target}")

        try:
            cmd = f"gobuster dir -u {target} -w {wordlist} -q -o /tmp/gobuster_output.txt"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            output_data = result.stdout
            if os.path.exists('/tmp/gobuster_output.txt'):
                with open('/tmp/gobuster_output.txt', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/gobuster_output.txt')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'gobuster'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'gobuster'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'gobuster'}

    def run_dirb(self, target, wordlist='/usr/share/wordlists/dirb/common.txt'):
        """Run DIRB directory brute forcing"""
        self.logger.info(f"Running DIRB on {target}")

        try:
            cmd = f"dirb {target} {wordlist} -o /tmp/dirb_output.txt -S"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            output_data = result.stdout
            if os.path.exists('/tmp/dirb_output.txt'):
                with open('/tmp/dirb_output.txt', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/dirb_output.txt')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'dirb'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'dirb'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'dirb'}

    def run_testssl(self, target):
        """Run testssl.sh SSL/TLS scanner"""
        self.logger.info(f"Running testssl.sh on {target}")

        try:
            cmd = f"testssl.sh --jsonfile /tmp/testssl_output.json {target}"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )

            output_data = result.stdout
            if os.path.exists('/tmp/testssl_output.json'):
                with open('/tmp/testssl_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/testssl_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'testssl'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'testssl'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'testssl'}

    def run_sslyze(self, target):
        """Run SSLyze SSL/TLS scanner"""
        self.logger.info(f"Running SSLyze on {target}")

        try:
            parsed = urlparse(target)
            host = parsed.netloc or parsed.path

            cmd = f"sslyze {host} --json_out=/tmp/sslyze_output.json"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )

            output_data = result.stdout
            if os.path.exists('/tmp/sslyze_output.json'):
                with open('/tmp/sslyze_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/sslyze_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'sslyze'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'sslyze'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'sslyze'}

    def run_wpscan(self, target):
        """Run WPScan for WordPress sites"""
        self.logger.info(f"Running WPScan on {target}")

        try:
            cmd = f"wpscan --url {target} --format json -o /tmp/wpscan_output.json --no-banner"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            output_data = result.stdout
            if os.path.exists('/tmp/wpscan_output.json'):
                with open('/tmp/wpscan_output.json', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/wpscan_output.json')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'wpscan'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'wpscan'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'wpscan'}

    def run_subfinder(self, domain):
        """Run Subfinder for subdomain enumeration"""
        self.logger.info(f"Running Subfinder on {domain}")

        try:
            cmd = f"subfinder -d {domain} -o /tmp/subfinder_output.txt -silent"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )

            output_data = result.stdout
            if os.path.exists('/tmp/subfinder_output.txt'):
                with open('/tmp/subfinder_output.txt', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/subfinder_output.txt')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'subfinder'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'subfinder'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'subfinder'}

    def run_amass(self, domain):
        """Run Amass for subdomain enumeration"""
        self.logger.info(f"Running Amass on {domain}")

        try:
            cmd = f"amass enum -d {domain} -o /tmp/amass_output.txt"
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600
            )

            output_data = result.stdout
            if os.path.exists('/tmp/amass_output.txt'):
                with open('/tmp/amass_output.txt', 'r') as f:
                    output_data = f.read()
                os.remove('/tmp/amass_output.txt')

            return {
                'success': result.returncode == 0,
                'output': output_data,
                'error': result.stderr,
                'tool': 'amass'
            }
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Timeout', 'tool': 'amass'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'tool': 'amass'}
