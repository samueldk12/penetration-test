#!/usr/bin/env python3
"""
Penetration Testing Proxy
Native HTTP/HTTPS proxy for request/response interception and analysis
"""

import sys
import json
import socket
import threading
import ssl
import time
import re
from datetime import datetime
from urllib.parse import urlparse
from http.server import BaseHTTPRequestHandler, HTTPServer
import io


class ProxyRequestHandler(BaseHTTPRequestHandler):
    """HTTP/HTTPS Proxy Request Handler"""

    protocol_version = 'HTTP/1.1'

    def __init__(self, *args, proxy_manager=None, **kwargs):
        self.proxy_manager = proxy_manager
        super().__init__(*args, **kwargs)

    def log_message(self, format, *args):
        """Override to custom logging"""
        if self.proxy_manager and self.proxy_manager.verbose:
            print(f"[PROXY] {format % args}")

    def do_CONNECT(self):
        """Handle HTTPS CONNECT method"""
        # Parse host and port
        host, port = self.path.split(':')
        port = int(port)

        try:
            # Connect to target server
            target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            target_sock.connect((host, port))

            # Send connection established
            self.send_response(200, 'Connection Established')
            self.end_headers()

            # Start SSL tunnel
            self.connection.setblocking(0)
            target_sock.setblocking(0)

            # Log connection
            if self.proxy_manager:
                self.proxy_manager.log_request({
                    'method': 'CONNECT',
                    'host': host,
                    'port': port,
                    'timestamp': datetime.now().isoformat(),
                    'ssl': True
                })

            # Tunnel data between client and server
            self.tunnel(self.connection, target_sock)

        except Exception as e:
            self.send_error(502, f'Bad Gateway: {str(e)}')

    def do_GET(self):
        """Handle GET requests"""
        self.handle_request('GET')

    def do_POST(self):
        """Handle POST requests"""
        self.handle_request('POST')

    def do_PUT(self):
        """Handle PUT requests"""
        self.handle_request('PUT')

    def do_DELETE(self):
        """Handle DELETE requests"""
        self.handle_request('DELETE')

    def do_HEAD(self):
        """Handle HEAD requests"""
        self.handle_request('HEAD')

    def do_OPTIONS(self):
        """Handle OPTIONS requests"""
        self.handle_request('OPTIONS')

    def handle_request(self, method):
        """Handle HTTP request"""
        try:
            # Parse URL
            url = self.path
            parsed = urlparse(url)

            # Get headers
            headers = {}
            for header, value in self.headers.items():
                headers[header] = value

            # Get request body
            body = None
            if 'Content-Length' in headers:
                content_length = int(headers['Content-Length'])
                body = self.rfile.read(content_length)

            # Log request
            request_data = {
                'method': method,
                'url': url,
                'host': parsed.netloc or headers.get('Host', ''),
                'path': parsed.path,
                'query': parsed.query,
                'headers': headers,
                'body': body.decode('utf-8', errors='ignore') if body else None,
                'timestamp': datetime.now().isoformat()
            }

            if self.proxy_manager:
                self.proxy_manager.log_request(request_data)

                # Check for vulnerabilities in request
                self.proxy_manager.analyze_request(request_data)

            # Forward request to target
            response = self.forward_request(method, url, headers, body)

            if response:
                # Send response to client
                self.send_response(response['status'])

                for header, value in response['headers'].items():
                    # Skip some headers
                    if header.lower() not in ['transfer-encoding', 'connection']:
                        self.send_header(header, value)

                self.end_headers()

                if response['body']:
                    self.wfile.write(response['body'])

                # Log response
                if self.proxy_manager:
                    response_data = {
                        'status': response['status'],
                        'headers': response['headers'],
                        'body': response['body'].decode('utf-8', errors='ignore') if response['body'] else None,
                        'timestamp': datetime.now().isoformat()
                    }

                    self.proxy_manager.log_response(request_data, response_data)

                    # Analyze response for vulnerabilities
                    self.proxy_manager.analyze_response(request_data, response_data)

        except Exception as e:
            print(f"[!] Error handling request: {e}")
            self.send_error(500, f'Internal Proxy Error: {str(e)}')

    def forward_request(self, method, url, headers, body):
        """Forward request to target server"""
        try:
            import requests

            # Prepare headers
            forward_headers = headers.copy()

            # Remove proxy-specific headers
            for header in ['Proxy-Connection', 'Proxy-Authorization']:
                forward_headers.pop(header, None)

            # Make request
            response = requests.request(
                method=method,
                url=url,
                headers=forward_headers,
                data=body,
                allow_redirects=False,
                timeout=30,
                verify=False  # Accept self-signed certs
            )

            return {
                'status': response.status_code,
                'headers': dict(response.headers),
                'body': response.content
            }

        except Exception as e:
            print(f"[!] Error forwarding request: {e}")
            return None

    def tunnel(self, client_sock, target_sock):
        """Tunnel data between client and target"""
        import select

        sockets = [client_sock, target_sock]
        timeout = 60

        while True:
            try:
                readable, _, exceptional = select.select(sockets, [], sockets, timeout)

                if exceptional:
                    break

                if not readable:
                    break

                for sock in readable:
                    data = sock.recv(8192)
                    if not data:
                        return

                    if sock is client_sock:
                        target_sock.sendall(data)
                    else:
                        client_sock.sendall(data)

            except Exception as e:
                break


class PentestProxy:
    """Penetration Testing Proxy Manager"""

    def __init__(self, port=8888, options=None):
        self.port = port
        self.options = options or {}

        self.verbose = self.options.get('verbose', True)
        self.log_file = self.options.get('log_file', 'proxy_log.json')
        self.analyze_enabled = self.options.get('analyze', True)
        self.save_enabled = self.options.get('save', True)

        self.server = None
        self.running = False

        # Storage
        self.requests = []
        self.responses = []
        self.vulnerabilities = []

        # Statistics
        self.stats = {
            'total_requests': 0,
            'total_responses': 0,
            'methods': {},
            'hosts': {},
            'vulnerabilities_found': 0
        }

    def log_request(self, request_data):
        """Log HTTP request"""
        self.requests.append(request_data)
        self.stats['total_requests'] += 1

        # Update method stats
        method = request_data.get('method', 'UNKNOWN')
        self.stats['methods'][method] = self.stats['methods'].get(method, 0) + 1

        # Update host stats
        host = request_data.get('host', 'UNKNOWN')
        self.stats['hosts'][host] = self.stats['hosts'].get(host, 0) + 1

        # Print request
        if self.verbose:
            print(f"\n[→] {method} {request_data.get('url', 'N/A')}")
            if request_data.get('body'):
                print(f"    Body: {request_data['body'][:100]}")

    def log_response(self, request_data, response_data):
        """Log HTTP response"""
        combined = {
            'request': request_data,
            'response': response_data
        }
        self.responses.append(combined)
        self.stats['total_responses'] += 1

        # Print response
        if self.verbose:
            print(f"[←] {response_data['status']} ({len(response_data.get('body', b''))} bytes)")

    def analyze_request(self, request_data):
        """Analyze request for vulnerabilities"""
        if not self.analyze_enabled:
            return

        vulns = []

        # Check for SQL injection patterns
        if request_data.get('body'):
            sql_patterns = [
                r"'\s*OR\s*'1'\s*=\s*'1",
                r"--",
                r";\s*DROP\s+TABLE",
                r"UNION\s+SELECT",
                r"'\s*OR\s*1\s*=\s*1",
            ]

            for pattern in sql_patterns:
                if re.search(pattern, request_data['body'], re.IGNORECASE):
                    vulns.append({
                        'type': 'sqli_attempt',
                        'severity': 'high',
                        'pattern': pattern,
                        'location': 'request_body',
                        'data': request_data['body'][:200]
                    })

        # Check for XSS patterns
        if request_data.get('body') or request_data.get('query'):
            xss_patterns = [
                r'<script[^>]*>',
                r'javascript:',
                r'onerror\s*=',
                r'onload\s*=',
            ]

            search_text = request_data.get('body', '') + request_data.get('query', '')

            for pattern in xss_patterns:
                if re.search(pattern, search_text, re.IGNORECASE):
                    vulns.append({
                        'type': 'xss_attempt',
                        'severity': 'medium',
                        'pattern': pattern,
                        'location': 'request_data'
                    })

        # Check for sensitive data in URL
        if request_data.get('query'):
            sensitive_patterns = [
                (r'password=', 'password_in_url'),
                (r'token=', 'token_in_url'),
                (r'api_key=', 'api_key_in_url'),
            ]

            for pattern, vuln_type in sensitive_patterns:
                if re.search(pattern, request_data['query'], re.IGNORECASE):
                    vulns.append({
                        'type': vuln_type,
                        'severity': 'medium',
                        'description': 'Sensitive data in URL query string',
                        'url': request_data.get('url', '')
                    })

        # Store vulnerabilities
        for vuln in vulns:
            vuln['timestamp'] = datetime.now().isoformat()
            vuln['request_url'] = request_data.get('url', '')
            self.vulnerabilities.append(vuln)
            self.stats['vulnerabilities_found'] += 1

            if self.verbose:
                print(f"[!] {vuln['type']}: {vuln.get('description', 'Detected')}")

    def analyze_response(self, request_data, response_data):
        """Analyze response for vulnerabilities"""
        if not self.analyze_enabled:
            return

        vulns = []

        # Check for sensitive data exposure
        body = response_data.get('body', '')
        if body:
            sensitive_patterns = [
                (r'[a-zA-Z0-9]{32,}', 'potential_token'),
                (r'-----BEGIN .* KEY-----', 'private_key_exposed'),
                (r'password\s*[:=]\s*["\']?[^"\'\s]+', 'password_exposed'),
            ]

            for pattern, vuln_type in sensitive_patterns:
                if re.search(pattern, body):
                    vulns.append({
                        'type': vuln_type,
                        'severity': 'high',
                        'description': 'Sensitive data in response',
                        'url': request_data.get('url', '')
                    })

        # Check for missing security headers
        headers = response_data.get('headers', {})
        security_headers = {
            'X-Frame-Options': 'Clickjacking protection missing',
            'X-Content-Type-Options': 'MIME sniffing protection missing',
            'Strict-Transport-Security': 'HSTS not enabled',
            'Content-Security-Policy': 'CSP not configured',
        }

        for header, description in security_headers.items():
            if header not in headers:
                vulns.append({
                    'type': 'missing_security_header',
                    'severity': 'low',
                    'header': header,
                    'description': description,
                    'url': request_data.get('url', '')
                })

        # Check for error messages
        if body:
            error_patterns = [
                (r'sql syntax', 'sql_error'),
                (r'mysql', 'mysql_error'),
                (r'postgresql', 'postgresql_error'),
                (r'exception', 'exception_exposed'),
                (r'stack trace', 'stack_trace_exposed'),
            ]

            for pattern, vuln_type in error_patterns:
                if re.search(pattern, body, re.IGNORECASE):
                    vulns.append({
                        'type': vuln_type,
                        'severity': 'medium',
                        'description': 'Error message exposed in response',
                        'url': request_data.get('url', '')
                    })

        # Store vulnerabilities
        for vuln in vulns:
            vuln['timestamp'] = datetime.now().isoformat()
            self.vulnerabilities.append(vuln)
            self.stats['vulnerabilities_found'] += 1

    def save_log(self):
        """Save proxy log to file"""
        if not self.save_enabled:
            return

        log_data = {
            'statistics': self.stats,
            'requests': self.requests[-1000:],  # Last 1000 requests
            'vulnerabilities': self.vulnerabilities,
            'timestamp': datetime.now().isoformat()
        }

        try:
            with open(self.log_file, 'w') as f:
                json.dump(log_data, f, indent=2)
            print(f"\n[+] Log saved to {self.log_file}")
        except Exception as e:
            print(f"[!] Failed to save log: {e}")

    def start(self):
        """Start proxy server"""
        print(f"[*] Starting Pentest Proxy on port {self.port}...")

        def handler(*args, **kwargs):
            ProxyRequestHandler(*args, proxy_manager=self, **kwargs)

        try:
            self.server = HTTPServer(('127.0.0.1', self.port), handler)
            self.running = True

            print(f"[+] Proxy listening on 127.0.0.1:{self.port}")
            print("[*] Configure your browser/app to use this proxy")
            print("[*] Press Ctrl+C to stop")

            print("\n" + "="*60)
            print("PROXY CONFIGURATION")
            print("="*60)
            print(f"  HTTP Proxy:  127.0.0.1:{self.port}")
            print(f"  HTTPS Proxy: 127.0.0.1:{self.port}")
            print("="*60 + "\n")

            # Start server
            self.server.serve_forever()

        except KeyboardInterrupt:
            print("\n[*] Stopping proxy...")
            self.running = False

        except Exception as e:
            print(f"[!] Proxy error: {e}")
            self.running = False

        finally:
            if self.server:
                self.server.shutdown()

            # Save log
            self.save_log()

            # Print summary
            self.print_summary()

    def print_summary(self):
        """Print proxy summary"""
        print("\n" + "="*60)
        print("PROXY SESSION SUMMARY")
        print("="*60)
        print(f"Total Requests:  {self.stats['total_requests']}")
        print(f"Total Responses: {self.stats['total_responses']}")
        print(f"Vulnerabilities: {self.stats['vulnerabilities_found']}")

        if self.stats['methods']:
            print("\nRequests by Method:")
            for method, count in self.stats['methods'].items():
                print(f"  {method}: {count}")

        if self.stats['hosts']:
            print("\nRequests by Host:")
            for host, count in sorted(self.stats['hosts'].items(), key=lambda x: x[1], reverse=True)[:10]:
                print(f"  {host}: {count}")

        if self.vulnerabilities:
            print(f"\nVulnerabilities Found: {len(self.vulnerabilities)}")
            vuln_types = {}
            for vuln in self.vulnerabilities:
                vuln_type = vuln['type']
                vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1

            for vuln_type, count in sorted(vuln_types.items(), key=lambda x: x[1], reverse=True):
                print(f"  {vuln_type}: {count}")

        print("="*60)


def main():
    """Main entry point"""
    if len(sys.argv) > 1:
        port = int(sys.argv[1])
    else:
        port = 8888

    options = {}
    if len(sys.argv) > 2:
        try:
            options = json.loads(sys.argv[2])
        except:
            print("[!] Invalid JSON options")

    proxy = PentestProxy(port, options)
    proxy.start()


if __name__ == "__main__":
    main()
