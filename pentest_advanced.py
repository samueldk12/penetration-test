#!/usr/bin/env python3
"""
Pentest Suite - Ferramenta Automatizada de Teste de Penetração
Versão Avançada com suporte a LLM, payloads customizados, múltiplas URLs, proxies, etc.

Autor: Pentest Suite Team
Versão: 2.0.0

AVISO LEGAL:
Esta ferramenta deve ser usada APENAS para fins educacionais e em sistemas
onde você tem AUTORIZAÇÃO EXPLÍCITA para realizar testes de segurança.
O uso não autorizado é ILEGAL e pode resultar em consequências legais.
"""

import argparse
import sys
import warnings
import os

from pentest_suite.modules.recon import ReconModule
from pentest_suite.modules.endpoint_discovery import EndpointDiscovery
from pentest_suite.modules.vuln_scanner import VulnerabilityScanner
from pentest_suite.modules.llm_scanner import LLMScanner
from pentest_suite.modules.reporter import Reporter
from pentest_suite.config import ScanConfig, ProxyManager, AuthManager
from pentest_suite.file_loader import (
    FileLoader, PayloadManager, TargetManager, TestSelector
)

# Desabilita warnings SSL para testes
warnings.filterwarnings('ignore', message='Unverified HTTPS request')


def print_banner():
    """Imprime banner da ferramenta"""
    banner = """
╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║   ██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗   ║
║   ██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝   ║
║   ██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║      ║
║   ██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║      ║
║   ██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║      ║
║   ╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝      ║
║                                                                   ║
║              Automated Penetration Testing Suite                 ║
║                OWASP Top 10 + LLM Testing - v2.0.0               ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

[!] AVISO LEGAL: Use apenas em sistemas autorizados!
"""
    print(banner)


def load_config(args):
    """Carrega configuração avançada"""
    config = ScanConfig(timeout=args.timeout)

    # Carrega config de arquivo se fornecido
    if args.config_file:
        config = ScanConfig.from_file(args.config_file)

    # Carrega proxies
    if args.proxy_list:
        proxy_manager = ProxyManager(args.proxy_list)
        config.proxy_list = proxy_manager.get_all()
        config.rotate_proxy = True
    elif args.proxy:
        config.proxies = {
            'http': args.proxy,
            'https': args.proxy
        }

    # Configurações de SSL
    if args.verify_ssl:
        config.verify_ssl = True

    if args.ssl_cert:
        config.ssl_cert = args.ssl_cert
        config.ssl_key = args.ssl_key

    # Configurações de autenticação
    if args.basic_auth:
        username, password = args.basic_auth.split(':', 1)
        config.auth_type = 'basic'
        config.username = username
        config.password = password

    elif args.bearer_token:
        config.auth_type = 'bearer'
        config.bearer_token = args.bearer_token

    elif args.auth_file:
        auth_config = AuthManager.load_from_file(args.auth_file)
        config.auth_type = auth_config.get('type')
        config.username = auth_config.get('username')
        config.password = auth_config.get('password')
        config.bearer_token = auth_config.get('token')

    # User-Agent customizado
    if args.user_agent:
        config.user_agent = args.user_agent

    return config


def load_targets(args):
    """Carrega lista de targets"""
    target_manager = TargetManager()

    if args.target_file:
        # Verifica se é JSON ou TXT simples
        if args.target_file.endswith('.json'):
            target_manager.load_from_file(args.target_file)
        else:
            target_manager.load_simple_urls(args.target_file)
    elif args.target:
        target_manager.add_target(args.target)
    else:
        print("[!] Erro: Nenhum target fornecido")
        sys.exit(1)

    return target_manager.get_targets()


def load_payloads(args):
    """Carrega payloads customizados"""
    payload_manager = PayloadManager()

    if args.payload_file:
        # Carrega payloads de arquivo específico
        category = args.payload_category or 'custom'
        payload_manager.load_category(category, args.payload_file)

    elif args.payload_dir:
        # Carrega todos os payloads de um diretório
        payload_manager.load_all_from_directory(args.payload_dir)

    return payload_manager


def load_test_selector(args):
    """Carrega seletor de testes"""
    test_selector = TestSelector()

    if args.tests_file:
        test_selector.load_from_file(args.tests_file)

    elif args.tests:
        for test in args.tests.split(','):
            test_selector.add_test(test.strip())

    return test_selector


def run_llm_scan(targets, args, config, payload_manager, test_selector):
    """Executa scan de vulnerabilidades em LLM"""
    print("\n[*] Modo LLM - Testando vulnerabilidades em Large Language Models")
    print("=" * 80)

    all_reports = []

    for target_info in targets:
        target = target_info['url']
        print(f"\n[*] Target: {target}")
        print("-" * 80)

        scanner = LLMScanner(
            api_endpoint=target,
            api_key=args.api_key,
            timeout=config.timeout,
            config=config,
            payload_manager=payload_manager,
            test_selector=test_selector
        )

        # Executa scan
        vulnerabilities = scanner.scan_all()
        report = scanner.get_report()

        # Gera relatório
        reporter = Reporter(output_dir=args.output)
        report_paths = reporter.generate_report(
            target=target,
            vuln_data=report,
            formats=args.format.split(',')
        )

        all_reports.append({
            'target': target,
            'report': report,
            'report_paths': report_paths
        })

    # Resumo final
    print("\n" + "=" * 80)
    print("SCAN LLM COMPLETO!")
    print("=" * 80)

    for report_info in all_reports:
        target = report_info['target']
        report = report_info['report']

        print(f"\n[Target: {target}]")
        print(f"  Total de vulnerabilidades: {report['total_vulnerabilities']}")

        for severity, count in report['by_severity'].items():
            if count > 0:
                print(f"  - {severity}: {count}")

        print(f"\n  Relatórios:")
        for path in report_info['report_paths']:
            print(f"    - {path}")


def run_web_scan(targets, args, config, payload_manager, test_selector):
    """Executa scan de vulnerabilidades web"""
    print("\n[*] Modo WEB - Testando vulnerabilidades web OWASP Top 10")
    print("=" * 80)

    for target_info in targets:
        target = target_info['url']
        print(f"\n[*] Target: {target}")
        print("=" * 80)

        recon_data = None
        endpoint_data = None
        vuln_data = None

        # FASE 1: RECONHECIMENTO
        if not args.skip_recon and test_selector.should_run('subdomain_enum'):
            print("\n[FASE 1] RECONHECIMENTO")
            print("-" * 80)

            recon = ReconModule(target, timeout=config.timeout)

            if args.subdomain_enum:
                recon.subdomain_enumeration()

            if args.port_scan:
                recon.port_scan()

            if args.tech_detect:
                url = target if target.startswith('http') else f"http://{target}"
                recon.detect_technologies(url)

            recon_data = recon.get_full_report()

        # FASE 2: DESCOBERTA DE ENDPOINTS
        if not args.skip_discovery:
            print("\n[FASE 2] DESCOBERTA DE ENDPOINTS")
            print("-" * 80)

            url = target if target.startswith('http') else f"http://{target}"
            discovery = EndpointDiscovery(url, timeout=config.timeout,
                                        max_depth=args.crawl_depth)

            if args.crawl and test_selector.should_run('crawl'):
                discovery.crawl()

            if args.bruteforce and test_selector.should_run('directory_bruteforce'):
                discovery.directory_bruteforce()

            discovery.check_common_files()

            if test_selector.should_run('api_discovery'):
                discovery.detect_api_endpoints()

            endpoint_data = discovery.get_full_report()

        # FASE 3: SCAN DE VULNERABILIDADES
        if not args.skip_vulnscan:
            print("\n[FASE 3] SCAN DE VULNERABILIDADES")
            print("-" * 80)

            url = target if target.startswith('http') else f"http://{target}"
            scanner = VulnerabilityScanner(url, timeout=config.timeout)

            endpoints = endpoint_data['discovered_endpoints'] if endpoint_data else [url]
            forms = endpoint_data['forms'] if endpoint_data else []

            scanner.scan_all(endpoints, forms)
            vuln_data = scanner.get_report()

        # FASE 4: GERAÇÃO DE RELATÓRIOS
        print("\n[FASE 4] GERAÇÃO DE RELATÓRIOS")
        print("-" * 80)

        reporter = Reporter(output_dir=args.output)
        report_formats = args.format.split(',')

        report_paths = reporter.generate_report(
            target=target,
            recon_data=recon_data,
            endpoint_data=endpoint_data,
            vuln_data=vuln_data,
            formats=report_formats
        )

        # RESUMO
        print("\n" + "=" * 80)
        print(f"SCAN COMPLETO PARA {target}!")
        print("=" * 80)

        if recon_data:
            print(f"\n[Reconhecimento]")
            print(f"  - Subdomínios: {len(recon_data.get('subdomains', []))}")
            print(f"  - Portas abertas: {len(recon_data.get('open_ports', []))}")

        if endpoint_data:
            print(f"\n[Descoberta]")
            print(f"  - Endpoints: {endpoint_data.get('total_endpoints', 0)}")
            print(f"  - Formulários: {len(endpoint_data.get('forms', []))}")

        if vuln_data:
            print(f"\n[Vulnerabilidades]")
            print(f"  - Total: {vuln_data['total_vulnerabilities']}")
            for severity, count in vuln_data['by_severity'].items():
                if count > 0:
                    print(f"  - {severity}: {count}")

        print(f"\n[Relatórios]")
        for report_path in report_paths:
            print(f"  - {report_path}")

        print("\n" + "=" * 80)


def main():
    parser = argparse.ArgumentParser(
        description='Pentest Suite - Automated Penetration Testing Tool (Advanced)',
        epilog='Use apenas em sistemas autorizados!',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    # Argumentos principais
    parser.add_argument('target', nargs='?', help='Target URL, IP ou domínio')

    parser.add_argument('-m', '--mode', choices=['full', 'recon', 'discovery', 'vulnscan', 'llm'],
                       default='full', help='Modo de execução (default: full)')

    # Arquivos de entrada
    input_group = parser.add_argument_group('Arquivos de Entrada')
    input_group.add_argument('--target-file', help='Arquivo com lista de targets')
    input_group.add_argument('--payload-file', help='Arquivo com payloads customizados')
    input_group.add_argument('--payload-dir', help='Diretório com arquivos de payloads')
    input_group.add_argument('--payload-category', help='Categoria do payload (sqli, xss, etc.)')
    input_group.add_argument('--tests-file', help='Arquivo com lista de testes específicos')
    input_group.add_argument('--tests', help='Lista de testes separados por vírgula')

    # Configuração avançada
    config_group = parser.add_argument_group('Configuração Avançada')
    config_group.add_argument('--config-file', help='Arquivo JSON de configuração')
    config_group.add_argument('--proxy', help='Proxy único (http://proxy:port)')
    config_group.add_argument('--proxy-list', help='Arquivo com lista de proxies')
    config_group.add_argument('--verify-ssl', action='store_true', help='Verificar certificados SSL')
    config_group.add_argument('--ssl-cert', help='Certificado SSL do cliente')
    config_group.add_argument('--ssl-key', help='Chave privada SSL do cliente')

    # Autenticação
    auth_group = parser.add_argument_group('Autenticação')
    auth_group.add_argument('--basic-auth', help='Basic Auth (user:pass)')
    auth_group.add_argument('--bearer-token', help='Bearer token')
    auth_group.add_argument('--api-key', help='API Key (para LLM)')
    auth_group.add_argument('--auth-file', help='Arquivo JSON com credenciais')

    # Opções de reconhecimento
    recon_group = parser.add_argument_group('Reconhecimento')
    recon_group.add_argument('--subdomain-enum', action='store_true',
                            help='Habilita enumeração de subdomínios')
    recon_group.add_argument('--port-scan', action='store_true',
                            help='Habilita scan de portas')
    recon_group.add_argument('--tech-detect', action='store_true',
                            help='Habilita detecção de tecnologias')

    # Opções de descoberta
    discovery_group = parser.add_argument_group('Descoberta de Endpoints')
    discovery_group.add_argument('--crawl', action='store_true',
                                help='Habilita web crawling')
    discovery_group.add_argument('--bruteforce', action='store_true',
                                help='Habilita directory bruteforce')
    discovery_group.add_argument('--crawl-depth', type=int, default=3,
                                help='Profundidade máxima do crawl (default: 3)')

    # Opções de skip
    skip_group = parser.add_argument_group('Skip Options')
    skip_group.add_argument('--skip-recon', action='store_true',
                           help='Pula fase de reconhecimento')
    skip_group.add_argument('--skip-discovery', action='store_true',
                           help='Pula fase de descoberta')
    skip_group.add_argument('--skip-vulnscan', action='store_true',
                           help='Pula fase de scan de vulnerabilidades')

    # Opções gerais
    parser.add_argument('-t', '--timeout', type=int, default=10,
                       help='Timeout para requisições em segundos (default: 10)')
    parser.add_argument('-o', '--output', default='reports',
                       help='Diretório para salvar relatórios (default: reports)')
    parser.add_argument('-f', '--format', default='json,html,txt',
                       help='Formatos de relatório separados por vírgula (default: json,html,txt)')
    parser.add_argument('--user-agent', help='User-Agent customizado')
    parser.add_argument('--verbose', action='store_true',
                       help='Modo verbose')
    parser.add_argument('--list-tests', action='store_true',
                       help='Lista todos os testes disponíveis')

    args = parser.parse_args()

    # Banner
    print_banner()

    # Lista testes e sai
    if args.list_tests:
        test_selector = TestSelector()
        test_selector.list_available_tests()
        sys.exit(0)

    # Validação do target
    if not args.target and not args.target_file:
        print("[!] Erro: Target ou target-file é obrigatório")
        parser.print_help()
        sys.exit(1)

    # Carrega configurações
    config = load_config(args)
    targets = load_targets(args)
    payload_manager = load_payloads(args)
    test_selector = load_test_selector(args)

    print(f"\n[!] Targets carregados: {len(targets)}")
    print(f"[!] Modo: {args.mode}")

    # Confirmação
    print(f"\n[?] Você tem autorização para realizar testes nestes sistemas? (yes/no): ", end='')
    confirmation = input().strip().lower()
    if confirmation not in ['yes', 'y', 'sim', 's']:
        print("\n[!] Operação cancelada.")
        sys.exit(0)

    # Executa modo selecionado
    try:
        if args.mode == 'llm':
            run_llm_scan(targets, args, config, payload_manager, test_selector)
        else:
            run_web_scan(targets, args, config, payload_manager, test_selector)

    except KeyboardInterrupt:
        print("\n\n[!] Scan interrompido pelo usuário")
        sys.exit(0)
    except Exception as e:
        print(f"\n[!] Erro durante execução: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
